{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started This resource is intended to help program the team robot if you are unsure of where to start or need guidance on specific topics. It is recommended to use the I'm New Here section to gain an understanding of FRC and basic programming/hardware background concepts. While this is intended to be used as a programming resource, an understanding of some hardware concepts will be necessary to program the robot. For specific instructions related to getting started with a new season, please refer to Build Season . Note General information or tips. Warning Something that can break your project. Danger This can permanently damage something. Tip Helpful shortcut or best practice. Info Neutral informational box. Important Important information. Useful Links Here are some useful links to help you: Quick Reference Sheet (Passwords/Login Info) - Must be logged into your OUHSD Google account to access Team GitHub WPILib Documentation Limelight Vision Documentation REV Robotics SPARK MAX Overview FRC Elastic Documentation CTRE Phoenix Tuner Documentation Choreo Autos FRC Radio Configuration Tool REV Hardware Client 2 Documentation WPILib Hardware Basics - Status Lights Reference You\u2019ll also need to look for the WPILib Java documentation for your competition year, as well as REVLib, Phoenix, the NavX, etc\u2026 (ex WPILib Java API Docs 2025, REV Java API Docs 2025).","title":"Start Here"},{"location":"Build%20Season/tuningswerve/","text":"Tuning Swerve Drive Systems What is Swerve Tuning? Swerve drive tuning is the process of optimizing your swerve drive system for best performance. This includes: - Calibrating absolute encoder offsets - Tuning PID controllers - Characterizing drive motors - Optimizing motion profiles - Testing and validating performance Tuning Overview The complete swerve tuning process involves several steps performed in order: 1. Module Calibration : - Align modules to zero position - Record CANCoder absolute positions - Calculate and apply offsets - Verify physical alignment 2. PID Tuning : - Tune steering PID (module angle control) - Tune drive PID (wheel velocity control) - Tune holonomic PID (path following X, Y, theta) 3. Drive Characterization : - Measure feedforward gains - Test maximum velocities and accelerations - Validate against theoretical calculations 4. Path Following Optimization : - Test simple autonomous paths - Tune trajectory following parameters - Optimize look-ahead and correction gains 5. Field Testing : - Test under realistic conditions - Verify odometry accuracy - Validate autonomous performance - Make final adjustments Required Tools and Setup Hardware : - Fully assembled swerve robot - Charged battery - Laptop with driver station - Measuring tape or field markers - Blocks or lift to suspend robot (for some tests) Software : - Latest robot code deployed - Dashboard (Shuffleboard, Elastic, etc.) - Phoenix Tuner X (for CANCoders) - REV Hardware Client (for SPARK MAXes) Safety First During tuning: - Keep robot in safe area with space to move - Have emergency stop ready - Start with low speeds - Gradually increase as confidence grows - Never tune with robot near people or fragile items - Be ready to disable immediately Recommended Tuning Order Week 1-2 (Basic Function) : 1. Module calibration (offsets) 2. Basic steering PID 3. Basic drive control 4. Test teleoperated drive Week 3-4 (Optimization) : 1. Fine-tune steering PID 2. Tune drive velocity PID 3. Drive characterization 4. Simple autonomous paths Week 5-6 (Path Following) : 1. Tune holonomic PID for path following 2. Test autonomous routines 3. Optimize trajectory generation 4. Field testing Week 7-8 (Competition Ready) : 1. Final validation and testing 2. Competition-specific tuning 3. Backup configurations 4. Driver practice Documentation During Tuning Keep a tuning log: - Date and who performed tuning - What was changed - Before and after values - Test results - Issues encountered - Final working values Update Constants.java with final values: public static final class ModuleConstants { // Offsets (date calibrated: 2025-01-15) public static final double FL_OFFSET = 0.237; // Steering PID (tuned: 2025-01-18) public static final double STEERING_P = 5.0; public static final double STEERING_I = 0.0; public static final double STEERING_D = 0.1; // Drive PID (tuned: 2025-01-20) public static final double DRIVE_P = 0.2; // ... } Common Issues and Solutions Robot doesn't drive straight : - Check module offsets - Verify motor inversions - Check wheel tread condition - Verify module positions in code Modules oscillate : - Reduce steering P gain - Increase steering D gain - Check for mechanical binding - Verify CANCoder magnet alignment Poor path following : - Tune holonomic PID - Check odometry accuracy - Verify gyro not drifting - Reduce maximum velocities Inconsistent performance : - Check battery voltage - Verify current limits - Test on charged battery - Check for loose connections Performance Validation After tuning, validate performance: - Drive test: Smooth, responsive control - Straight line: < 5cm deviation over 5m - Rotation: < 2\u00b0 error in 360\u00b0 rotation - Path following: < 10cm error on complex paths - Repeatability: Consistent performance over multiple runs Resources See detailed guides: - PID Tuning (pidtuning.md) - Testing and Calibration (testingcalibration.md) - WPILib Swerve Documentation - Team 364 Swerve Code (BaseFalconSwerve) - Chief Delphi tuning discussions","title":"Tuningswerve"},{"location":"Build%20Season/Notes/notes/","text":"Build Season Notes Warning The contents of the Build Season section are not applicable until after Kickoff. You can get started with some basics right after kickoff, specifically updating software. You cannot update software, tune swerve, or physically test any new subsystems you write until after the robot is built. Important Through build season, make sure to commit code frequently with clear commit messages. Comment your additions and document major changes. Test your code as frequently and as soon as possible. Programming Priorities During Build Season Step 1 - Kickoff Update software. Set up new repository for season. Import and update previous year's code. Talk to CAD Team -> You'll need to know what specific components will be going on the robot and how many motors each will use. Talk about planned behaviors for each component so you know what to program. Create basic subsystems for planned mechanisms, assuming CAN IDs. Start creating basic autos. Step 2 Info You'll need a fully built and wired chassis to complete this step. Tune swerve. Update firmware for anything currently on the robot. Start training Limelight neural networks. Deploy Step 3 Info You'll need the robot to be fully built with all components to complete this step. Update firmware for any remaining components. Update controls. Test autonomous routines. Test limelight integration. Practice driving the robot.","title":"Notes"},{"location":"Build%20Season/Season%20Overview/seasonoverview/","text":"Season Overview Use the links below to access the season-specific changes to WPILib . Known WPILib Issues New For This Season Info Each year, some game specific data will be sent from the FMS . If you'd like to incorporate this data into your code, WPILib gives instructions on how to do so. Game Specific Data","title":"Season Overview"},{"location":"Build%20Season/Tuning%20Swerve/pidtuning/","text":"PID Tuning for Swerve Drive What is PID Control? PID (Proportional-Integral-Derivative) control is used to continuously calculate the \"value of error\" and apply a corresponding correction. For swerve drive, PID controllers are used to calculate the correction needed for in: - Module steering (turning each wheel to desired angle) - Module drive (controlling wheel velocity) - Auto path following (X, Y, and rotation) PID Components Explained It is not important to understand how PID works exactly , however, an understanding of how adjusting each value affects the swerve drive is important. Assume the \"target\" for these cases is a straight line a few feet away from the robot's starting position. Proportional (P) : Adjust when: Your robot is too slow to reach the target or overshoots wildly. Increase P: if the robot moves too slowly toward the target. Decrease P: if it oscillates back and forth or overshoots. Integral (I) : Adjust when: The robot never quite reaches the target and gets stuck a little short. Increase I: if it consistently undershoots. Decrease I: if the robot starts \u201cwobbling\u201d around the target or oscillates after reaching it. Derivative (D) : Adjust when: The robot overshoots or bounces around the target. Increase D: to smooth motion and reduce overshoot. Decrease D: if the robot feels too sluggish or doesn\u2019t reach the target fast enough Tuning Process Danger Tuning is only necessary when your swerve drive oscillates or overshoots/undershoots your target. If the robot does not drive straight, that is likely related to a swerve offset issue, NOT a PID one. ALWAYS set swerve offsets before deciding whether or not PID tuning is necessary. Info The robot uses 4 PID controllers: 1 ( turnPidController ) in SwerveModule.java which controls PID in teleop, and 3 ( pathXController, pathYController, pathThetaController ) in SwerveSubsystem.java which control PID in autonomous path following. Other references to PID controllers in the code are overwritten by these 4 and should not be changed. Start with All Zeros : PIDController controller = new PIDController(0, 0, 0); Step 1: Tune P : 1. Set I = 0, D = 0 2. Increase P gradually (start with 0.1, 0.5, 1.0, etc.) 3. After each increase, deploy your update and test - you are looking for a quick reaction 4. If the wheels begin to oscillate , reduce your P until the issue goes away. 5. You should now have a good P value (typically 2 digits of precision, ex. 0.12) Step 2: Tune D : 1. Keep P from Step 1, I = 0 2. Increase D gradually (usually 5-20x smaller than P) 3. After each increase, deploy your update and test - you are looking to reduce overshoot 4. If the wheels begin to oscillate , reduce your D until the issue goes away. 5. You should now have a good D value (typically 2 digits of precision, ex. 0.12) Note Often, I = 0 works fine for swerve. Step 3: Tune I (if needed) : 1. Keep P and D from previous steps 2. Increase I VERY gradually (0.001, 0.01, 0.1) 3. After each increase, deploy your update and test - you are looking to reduce undershoot 4. You should now have a good P value (typically 2-4 digits of precision, ex. 0.12, 0.123 or 0.1234) Common PID Issues Oscillation : - P too high - reduce P - D too low - increase D - Check for mechanical issues Slow Response : - P too low - increase P Never Reaches Target : - Add I term (carefully) - Check for mechanical issues Overshoots Target : - P too high - reduce P - D too low - increase D","title":"PID Tuning"},{"location":"Build%20Season/Tuning%20Swerve/testingcalibration/","text":"Testing and Calibrating Swerve Modules Why Calibrate Swerve Modules? Each swerve module needs calibration to: - Establish absolute zero position for steering - Ensure wheels point in correct directions - Account for mechanical variations between modules - Enable accurate odometry and path following Without proper calibration, the robot will drive incorrectly and autonomous will fail. Understanding Absolute Encoders CANCoders are absolute encoders: - Report position from 0-360 degrees (or 0-1 rotation) - Position maintained through power cycles - Each module's \"zero\" is at a different absolute position - We use offsets to align all modules to same reference Calibration Procedure Step 1: Physical Alignment : 1. Place robot on blocks or with wheels off ground 2. Manually rotate each module to \"zero position\" - Wheel bevel gears facing inward (toward robot center) - Or all wheels pointing forward (parallel to robot length) 3. Lock modules in this position (or have helper hold) Step 2: Read Absolute Positions : For each module, read the CANCoder position: // In module class or test code public double getAbsolutePosition() { return canCoder.getAbsolutePosition(); // Returns 0-1 rotation } Or use Phoenix Tuner X: 1. Connect to robot 2. Select each CANCoder 3. Note \"Absolute Position\" value 4. Record for each module Step 3: Calculate Offsets : The offset is the reading when module is at zero: // If module reads 0.237 when physically at zero public static final double FRONT_LEFT_OFFSET = 0.237; Convert to degrees if needed: double offsetDegrees = offsetRotations * 360.0; Step 4: Apply Offsets in Code : public class SwerveModule { private final CANCoder canCoder; private final double offset; public SwerveModule(..., double offset) { this.offset = offset; // ... } public double getAngle() { // Get position and subtract offset double position = canCoder.getAbsolutePosition(); return (position - offset) * 360.0; // Convert to degrees } } Step 5: Verify Calibration : 1. Deploy updated code 2. Manually rotate modules to zero position 3. Check that getAngle() reports close to 0\u00b0 4. Repeat for all modules 5. Test drive - robot should drive straight Testing Module Operation Individual Module Test : Create a test command that exercises one module: public class TestSwerveModule extends CommandBase { private final SwerveModule module; private final int testNumber; @Override public void initialize() { testNumber = 0; } @Override public void execute() { switch (testNumber) { case 0: module.setState(new SwerveModuleState(0.5, Rotation2d.fromDegrees(0))); break; case 1: module.setState(new SwerveModuleState(0.5, Rotation2d.fromDegrees(90))); break; case 2: module.setState(new SwerveModuleState(0.5, Rotation2d.fromDegrees(180))); break; case 3: module.setState(new SwerveModuleState(0.5, Rotation2d.fromDegrees(270))); break; } } } All Modules Test : Test all modules together: 1. Command 0\u00b0 - all wheels forward 2. Command 90\u00b0 - all wheels left 3. Command 180\u00b0 - all wheels backward 4. Command 270\u00b0 - all wheels right Verify : - All modules rotate to correct angle - Wheel direction matches commanded direction - No excessive delay or oscillation - Modules return to same position repeatedly Drive Direction Testing Test Forward Drive : // All modules at 0\u00b0, positive speed swerveSubsystem.drive(0.3, 0, 0, false); Robot should drive straight forward If drifts, check module steering offsets If drives wrong direction, check motor inversions Test Strafe : // Test left strafe swerveSubsystem.drive(0, 0.3, 0, false); Robot should strafe left Wheels should point 90\u00b0 left Check coordination between modules Test Rotation : // Test counter-clockwise rotation swerveSubsystem.drive(0, 0, 0.3, false); Robot should spin in place All wheels should point tangent to circle Check module positions and inversions Odometry Verification After calibration, test odometry accuracy: Straight Line Test : 1. Place robot at known position 2. Reset odometry to (0, 0) 3. Drive straight for measured distance (e.g., 3 meters) 4. Check odometry reports close to expected distance 5. Error should be < 5% Square Pattern Test : 1. Reset odometry 2. Drive square pattern (1m each side) 3. Return to start 4. Check if odometry returns close to (0, 0) 5. Measure drift over time Rotation Test : 1. Reset odometry heading 2. Rotate 360\u00b0 (one full rotation) 3. Check heading returns close to 0\u00b0 4. Verify gyro integration with encoders Common Calibration Issues Robot Drives in Wrong Direction : - Check motor inversions - Verify module position configuration - Check drive encoder phase Modules Don't Align Correctly : - Recheck offsets - Verify CANCoder wiring and configuration - Check for mechanical slop Inconsistent Module Angles : - Check CANCoder magnet alignment (should be green LED) - Verify no interference with encoder - Check for loose mounting Odometry Drifts Over Time : - Wheel slippage (use proper wheels for surface) - Incorrect wheel radius in constants - Module positions incorrect - Gyro drift (verify NavX calibration) Field-Centric Drive Test After calibration, test field-centric drive: 1. Enable field-centric mode 2. Rotate robot 90\u00b0 clockwise 3. Push joystick forward 4. Robot should still drive toward the front of the field 5. Verify gyro integration working Autonomous Path Test Final calibration test with autonomous: 1. Create simple straight-line path 2. Place robot at starting position 3. Reset odometry 4. Run autonomous 5. Measure actual vs expected end position 6. Iterate on calibration if needed Maintenance and Recalibration Recalibrate when: - Changing swerve module components - CANCoder gets bumped or remounted - After significant impact/damage - Odometry becomes inaccurate - Before major competitions Documentation Document your calibration: // ModuleConstants.java public static final double FL_OFFSET = 0.237; // Measured 2025-01-15 public static final double FR_OFFSET = 0.891; // Measured 2025-01-15 public static final double RL_OFFSET = 0.445; // Measured 2025-01-15 public static final double RR_OFFSET = 0.672; // Measured 2025-01-15 Keep a calibration log: - Date calibrated - Who performed calibration - What changes were made - Test results","title":"Swerve Offsets"},{"location":"Build%20Season/Updating%20Autos/updatingautoroutines/","text":"Updating Auto Routines using Choreo Auto Routine Planning Before creating paths in Choreo: - Study the game : Understand scoring and strategy - Plan routes : Sketch paths on field diagram - Consider timing : Calculate cycle times - Identify constraints : Note obstacles and tight spaces - Prioritize : Start with most important autos Creating Paths in Choreo 1. Open Choreo Project : - Launch Choreo - Ensure robot configuration is correct - Load field layout for current game 2. Create New Trajectory : - Click \"New Trajectory\" - Give descriptive name (e.g., \"FourNoteCenter\") - Set starting position 3. Add Waypoints : - Click on field to place waypoints - Drag to adjust positions - Add as many as needed for complex paths - Consider game piece and scoring locations 4. Set Constraints : - Initial velocity : Usually 0 (starting from rest) - Final velocity : 0 for stopping, or match next path - Max velocity : Overall or per segment - Heading : Robot orientation at each point - Keep out zones : Avoid obstacles 5. Tune Path : - Adjust waypoints for smooth curves - Modify constraints for optimal speed - Preview trajectory timing - Check for constraint violations 6. Export Trajectory : - Click Export - Choose WPILib format - Save to src/main/deploy/choreo/ directory Path Types Scoring Paths : - Start from starting zone - Navigate to scoring location - Consider approach angle - Account for mechanism deploy time Game Piece Pickup Paths : - Navigate to game piece location - Slow down for intake engagement - Consider intake mechanism reach Return Paths : - From game pieces back to scoring - Can be faster (no precision needed) - Optimize for time Multi-Part Autos : - Chain multiple paths together - Match ending/starting velocities - Consider robot state between paths Integrating with Robot Code After exporting from Choreo: 1. Verify Files Deployed : - Check src/main/deploy/choreo/ contains .traj files - Ensure files are committed to Git 2. Load in Autos.java : ChoreoTrajectory trajectory = Choreo.getTrajectory(\"PathName\"); 3. Create Follow Command : Command followPath = Choreo.choreoSwerveCommand( trajectory, swerve::getPose, xPIDController, yPIDController, rotPIDController, swerve::setModuleStates, swerve ); 4. Add to Autonomous Selector : autoChooser.addOption(\"4 Note Auto\", Autos.fourNoteAuto(swerve, intake, shooter)); Testing Auto Routines Simulation Testing : - Test in WPILib simulation first - Verify path generation correct - Check timing and velocities - Identify obvious errors Practice Field Testing : 1. Clear the practice area 2. Place robot at starting position 3. Reset odometry to starting pose 4. Run autonomous 5. Observe and record results 6. Measure end position accuracy Iteration Process : - Identify issues (overshooting, missed targets) - Adjust Choreo constraints or waypoints - Re-export and re-deploy - Test again - Repeat until reliable Common Auto Patterns Simple Autos (1-2 actions) : - Score preload and leave community - Score preload and pickup one piece Medium Autos (3-4 actions) : - Score preload, pickup and score 2 more - Multi-position scoring Complex Autos (5+ actions) : - Full auto cycle (4-5 game pieces) - Dynamic path selection - Vision-assisted pickup Strategy Considerations Alliance Color : - May need mirrored paths for red vs blue - Choreo can mirror paths automatically - Test both configurations Starting Position : - Create autos for each starting position - Consider alliance partner selection - Have backup options Reliability vs Speed : - Start conservative, optimize later - Balance cycle time with success rate - Have reliable fallback autos Debugging Auto Issues Robot doesn't follow path : - Check odometry accuracy - Verify PID tuning - Confirm starting position reset correctly - Check wheel characterization Path generation fails : - Reduce max velocity/acceleration - Adjust waypoint spacing - Check for impossible constraints - Verify robot configuration Robot overshoots/undershoots : - Tune PID controllers - Adjust look-ahead distance - Modify path constraints - Check actual vs theoretical max speed Competition Preparation Before competition: - Test all autos multiple times - Create selection matrix (position + strategy) - Document auto routines for drive team - Have simple fallback autos - Practice autonomous selection process - Log auto performance data Best Practices Start simple, add complexity gradually Test frequently during development Version control all path files Name paths descriptively Document auto sequence and timing Create visualization for drive team Always have a \"do nothing\" option Practice match procedures","title":"Updating Auto Routines using Choreo"},{"location":"Build%20Season/Updating%20Autos/updatingrobotdetailsinchoreo/","text":"Updating Robot Details in Choreo Why Update Robot Details? Accurate robot configuration in Choreo is critical for generating trajectories that: - Match your robot's physical capabilities - Don't violate motion constraints - Execute reliably on the actual robot - Optimize for speed without sacrificing control When to Update Robot Details Update robot details when: - Starting a new season - Robot design changes (dimensions, weight) - Changing drivetrain motors or gearing - Modifying wheel size - After tuning PID or motion profiling - Swerve module configuration changes Robot Configuration Parameters Physical Dimensions : - Robot Width : Bumper-to-bumper width (meters) - Robot Length : Bumper-to-bumper length (meters) - Mass : Total robot weight with battery (kg) - Moment of Inertia : Rotational inertia (kg\u22c5m\u00b2) Swerve Module Configuration : - Module Positions : X and Y coordinates from robot center - Wheel Radius : Actual measured radius (meters) - Drive Gearing : Gear ratio from motor to wheel - Steering Gearing : Gear ratio for module rotation Performance Limits : - Max Velocity : Maximum linear speed (m/s) - Max Acceleration : Maximum linear acceleration (m/s\u00b2) - Max Angular Velocity : Maximum rotation speed (rad/s) - Max Angular Acceleration : Maximum rotational acceleration (rad/s\u00b2) Motor Configuration : - Motor Type : NEO, Falcon 500, etc. - Number of Motors : Per drive module - Current Limit : Sustained and peak current Measuring Robot Parameters Dimensions : - Measure with tape measure (outside of bumpers) - Convert to meters - Be precise - affects collision detection Mass : - Weigh complete robot with battery - Convert to kilograms - Update if adding/removing components Wheel Radius : - Measure actual wheel diameter - Account for compression under load - Test empirically (drive known distance) Maximum Velocities : - Test on field with full power - Measure using odometry or external tracking - Use conservative values for safety Module Positions : - Measure from robot center to wheel contact points - Use CAD measurements if available - Verify orientation (X forward, Y left) Configuring in Choreo 1. Open Choreo Project : - Launch Choreo - Open your project or create new 2. Access Robot Configuration : - Go to Settings or Robot Config menu - Select robot configuration tab 3. Enter Parameters : - Input all measured/calculated values - Double-check units (meters, kg, radians) - Verify module positions correct 4. Save Configuration : - Save project file - Version control changes - Document parameter sources Validating Configuration After updating parameters: - Generate test path : Simple straight line or circle - Check velocities : Should match robot capabilities - Export and test : Run on real robot - Compare results : Does robot follow path accurately? - Adjust if needed : Iterate on parameters Common Configuration Mistakes Wrong units : Mixing inches and meters Module positions : Incorrect sign or orientation Unrealistic limits : Too high causes unstable paths Gear ratios : Using wrong ratio calculation Wheel radius : Not accounting for compression Mass : Forgetting battery weight Configuration Templates Save proven configurations: - Create template for your robot type - Share with team members - Document changes between seasons - Keep in version control Testing and Iteration Validate configuration through testing: 1. Create simple test paths (straight, circle, square) 2. Deploy to robot and execute 3. Measure actual vs expected performance 4. Adjust parameters based on results 5. Re-generate paths with new config 6. Repeat until accurate Best Practices Measure carefully and document Use conservative performance limits initially Test simple paths before complex autos Update configuration when robot changes Keep configuration in version control Share configuration with team Revalidate after mechanical changes","title":"Updating Robot Details in Choreo"},{"location":"Build%20Season/Updating%20Code/addingnewfeatures/","text":"Adding New Features Feature Planning Before coding, plan the feature: - Define requirements : What should it do? - Design interface : How will drivers use it? - Identify dependencies : What subsystems/hardware needed? - Estimate complexity : How long will it take? - Consider alternatives : Is there a simpler approach? Feature Development Process 1. Create GitHub Issue : - Describe the feature - List acceptance criteria - Assign to team member - Add labels and milestone 2. Create Feature Branch : git checkout -b feature/new-auto-align 3. Design Before Coding : - Sketch class structure - Identify needed methods - Plan command composition - Discuss with team 4. Implement Incrementally : - Start with simplest version - Test frequently - Add complexity gradually - Keep commits small 5. Test Thoroughly : - Unit test if possible - Test on practice robot - Verify edge cases - Get driver feedback 6. Code Review : - Create pull request - Explain changes - Address feedback - Get approval 7. Merge and Deploy : - Merge to main branch - Deploy to robot - Final testing - Close issue Adding New Subsystems Step 1: Create Subsystem Class : public class ExampleSubsystem extends SubsystemBase { // Hardware declarations private final CANSparkMax motor; public ExampleSubsystem() { // Initialize hardware motor = new CANSparkMax( Constants.ExampleConstants.MOTOR_ID, MotorType.kBrushless ); configureMotor(); } private void configureMotor() { // Configuration } @Override public void periodic() { // Telemetry } } Step 2: Add Constants : public static final class ExampleConstants { public static final int MOTOR_ID = 10; public static final double MAX_SPEED = 1.0; } Step 3: Create in RobotContainer : private final ExampleSubsystem exampleSubsystem = new ExampleSubsystem(); Step 4: Test Subsystem : - Deploy and verify hardware responds - Check telemetry displays correctly - Test basic operations Adding New Commands Step 1: Create Command Class : public class ExampleCommand extends CommandBase { private final ExampleSubsystem subsystem; public ExampleCommand(ExampleSubsystem subsystem) { this.subsystem = subsystem; addRequirements(subsystem); } @Override public void initialize() { // Setup } @Override public void execute() { // Main logic } @Override public void end(boolean interrupted) { // Cleanup } @Override public boolean isFinished() { return false; } } Step 2: Bind to Controller : driverController.a().onTrue(new ExampleCommand(exampleSubsystem)); Step 3: Test Command : - Test button binding - Verify command executes - Check end behavior - Test interruption Adding Autonomous Features Create Auto Command : public static Command newAuto( SwerveSubsystem swerve, ExampleSubsystem example) { return Commands.sequence( Commands.runOnce(() -> swerve.resetOdometry(startPose)), followPath(swerve, \"Path1\"), new ExampleCommand(example), followPath(swerve, \"Path2\") ); } Add to Selector : autoChooser.addOption(\"New Auto\", Autos.newAuto(swerve, example)); Adding Vision Features Integration Steps : 1. Configure Limelight pipeline 2. Create vision subsystem or add to existing 3. Add commands for vision-assisted operations 4. Test with AprilTags 5. Tune for accuracy and speed Example Vision Alignment : public class AlignToTarget extends CommandBase { private final SwerveSubsystem swerve; private final PIDController rotController; public AlignToTarget(SwerveSubsystem swerve) { this.swerve = swerve; this.rotController = new PIDController(0.1, 0, 0); addRequirements(swerve); } @Override public void execute() { double tx = LimelightHelpers.getTX(\"limelight\"); double rotSpeed = rotController.calculate(tx, 0); swerve.drive(0, 0, rotSpeed, false); } @Override public boolean isFinished() { return Math.abs(LimelightHelpers.getTX(\"limelight\")) < 2.0; } } Adding Safety Features Limit Switches : public void setSpeed(double speed) { if (speed > 0 && upperLimitSwitch.get()) { speed = 0; // Stop at upper limit } if (speed < 0 && lowerLimitSwitch.get()) { speed = 0; // Stop at lower limit } motor.set(speed); } Soft Limits : public void setPosition(double targetPosition) { targetPosition = MathUtil.clamp( targetPosition, Constants.MIN_POSITION, Constants.MAX_POSITION ); // Set position } Current Monitoring : @Override public void periodic() { double current = motor.getOutputCurrent(); if (current > Constants.MAX_CURRENT) { motor.set(0); System.err.println(\"Motor current limit exceeded!\"); } } Testing New Features Simulation Testing : - Test basic logic without hardware - Verify command scheduling - Check for exceptions Practice Robot Testing : - Test on practice robot first - Verify hardware interactions - Test edge cases Competition Robot Testing : - Test after verifying on practice bot - Have someone watch closely - Be ready to disable - Test in safe conditions Documenting New Features Code Comments : - Explain why, not just what - Document assumptions - Note limitations README Updates : - List new features added - Explain how to use - Document any configuration Driver Documentation : - Update control mapping - Explain new button functions - Note any behavior changes Common Mistakes to Avoid Adding too many features at once Not testing incrementally Skipping code review Ignoring driver feedback Over-engineering solutions Not considering robot constraints Adding features too close to competition Forgetting to update documentation Best Practices Start simple, add complexity as needed Test each feature independently Get driver feedback early Use version control properly Write self-documenting code Consider failure modes Plan for competition conditions Have disable/fallback options","title":"Adding New Features"},{"location":"Build%20Season/Updating%20Code/deployingcode/","text":"Deploying Robot Code Why Deploy Code? Deploying code to the robot is a critical step in the development process: - Allows testing of new features - Verifies hardware and software integration - Ensures the robot is competition-ready - Provides a feedback loop for debugging Before Deploying Preparation Steps : 1. Verify code compiles without errors 2. Ensure all dependencies are up-to-date 3. Check team number in project settings 4. Confirm RoboRIO firmware is current 5. Test in simulation (if applicable) Robot Setup : - Ensure RoboRIO is powered on - Connect to the robot via USB or Wi-Fi - Verify all hardware connections are secure - Check battery voltage is sufficient Deployment Methods Method 1: Deploy via VS Code (Recommended): 1. Open the project in VS Code 2. Press Ctrl+Shift+P 3. Select \"WPILib: Deploy Robot Code\" 4. Monitor the terminal for deployment status Method 2: Deploy via Command Line : # Navigate to project directory cd /path/to/project # Deploy code to robot ./gradlew deploy Method 3: Offline Deployment : 1. Build the project locally 2. Transfer the build files to the RoboRIO 3. Use SSH to manually deploy the code Post-Deployment Checks After deploying, verify the following: 1. Code Runs Successfully : Check Driver Station logs for errors 2. Subsystems Respond : Test basic functionality (e.g., drive, intake) 3. Dashboard Updates : Ensure telemetry data is visible 4. Network Stability : Verify no connection drops Debugging Deployment Issues Common Issues : - Deployment Fails : Check team number, network connection, and RoboRIO firmware - Code Crashes : Review logs for stack traces and fix errors - Subsystems Unresponsive : Verify CAN IDs, wiring, and hardware status Troubleshooting Steps : 1. Rebuild the project: ./gradlew clean build 2. Restart the RoboRIO 3. Check Driver Station logs for detailed error messages 4. Test individual subsystems to isolate issues Best Practices Deploy frequently during development Test on a practice robot before competition Keep a backup of the last working code Document changes and deployment steps Use version control to track code history Team Onboarding Help team members understand the deployment process: - Provide a walkthrough of deployment steps - Share troubleshooting tips - Assign deployment tasks during testing - Encourage documenting deployment issues and resolutions","title":"Deploying Code"},{"location":"Build%20Season/Updating%20Code/importinglastyearscode/","text":"Importing Last Year's Robot Code Why Import Last Year's Code? Starting with previous year's code: - Saves weeks of development time - Proven, tested codebase - Familiar structure for returning members - Working examples of subsystems - Established patterns and practices Before Importing Preparation Steps : 1. Review last year's code and identify what worked 2. Document known bugs or issues to fix 3. Check for pending pull requests 4. Note any season-specific code to remove 5. Plan which components are reusable Create New Repository : - Don't modify last year's repo directly - Create new repo for current season (e.g., \"2025-RobotCode\") - Use descriptive name with year - Initialize with README and .gitignore Import Methods Method 1: Clone and Reset (Recommended): # Clone last year's repo git clone https://github.com/YourTeam/2024-RobotCode.git 2025-RobotCode # Navigate into directory cd 2025-RobotCode # Change remote to new repo git remote set-url origin https://github.com/YourTeam/2025-RobotCode.git # Push to new repository git push -u origin main Method 2: Copy Files : 1. Download last year's code as ZIP 2. Create new WPILib project 3. Copy relevant files into new project 4. Commit to new repository 5. Note: Loses Git history Method 3: Template Repository : 1. Make last year's repo a template on GitHub 2. Create new repo from template 3. Maintains structure without full history Initial Cleanup After importing, clean up the code: Update Project Information : - Robot name and year in README - Team number verification in Constants - Remove old season references - Update year in comments Remove Game-Specific Code : - Season-specific subsystems (2024 intake, etc.) - Game piece specific logic - Old auto routines (keep for reference) - Scoring mechanism code Update Dependencies : - Update WPILib to current year - Update vendor dependencies (REV, CTRE, etc.) - Remove unused vendordeps - Verify compatibility Clean Up Build Files : # In project directory ./gradlew clean Remove build artifacts: - build/ directory - .gradle/ directory - Compiled class files What to Keep Core Framework : - RobotContainer structure - Command-based architecture - Constants organization - Utility classes Drive Subsystem : - Swerve drive code (if using swerve) - Odometry implementation - Field-centric drive - Auto-align commands Infrastructure : - Logging utilities - Dashboard integration - Auto command framework - Simulation support Proven Patterns : - PID implementations - State machines - Command compositions - Testing utilities What to Modify/Remove Remove : - Game-specific subsystems - Old auto routines (or move to archive) - Hardcoded game field positions - Season-specific utilities Modify : - CAN IDs (hardware may change) - Physical constants (new robot dimensions) - Control mappings (keep same, or update) - PID values (re-tune for new mechanisms) Update Vendor Dependencies In VS Code: 1. Press Ctrl+Shift+P 2. \"WPILib: Manage Vendor Libraries\" 3. \"Check for updates (online)\" 4. Update all libraries 5. Build project to verify Initial Testing After import and cleanup: 1. Build Project : Verify no compilation errors 2. Simulate : Test basic drive functions 3. Deploy to Practice Robot : If available 4. Test Drive System : Verify basic control 5. Check Constants : Verify all values appropriate Documentation Updates Update documentation: - README with new season info - Architecture diagram if changed - Contributing guidelines - Setup instructions - Known issues list Team Onboarding Help team members get started: - Share new repository link - Provide setup instructions - Schedule code walkthrough - Assign initial tasks - Create issues for planned work Best Practices Import early in build season Test thoroughly before modifying Keep last year's repo as reference Document what changed and why Create branch for import/cleanup Get code review before merging Version control everything Test on practice robot first Common Issues Build Errors After Import : - Update vendor dependencies - Check WPILib year is correct - Clean and rebuild - Verify Java version Deploy Fails : - Update SystemCore/RoboRIO firmware - Check team number in settings - Verify USB/network connection - Update robot configuration Code Doesn't Work : - Verify CAN IDs match hardware - Check wiring matches expectations - Re-tune PID values - Test each subsystem individually","title":"Importing Last Year's Robot Code"},{"location":"Build%20Season/Updating%20Code/refactoringcode/","text":"Refactoring Code What is Refactoring? Refactoring is restructuring existing code without changing its external behavior. The goals are to: - Improve code readability - Reduce complexity - Eliminate duplication - Make code easier to maintain - Prepare for new features Important : Refactoring is NOT adding features or fixing bugs. It's improving the code structure. When to Refactor Good times to refactor: - After getting last year's code working - Before adding major new features - When code becomes hard to understand - When finding duplicated code - When tests are passing Don't refactor : - Right before competition - When code is unstable - Without tests or backup - When you don't understand the code Common Refactoring Patterns Extract Method : Replace duplicated or complex code with a method: // Before double xSpeed = -driverController.getLeftY(); xSpeed = Math.abs(xSpeed) < 0.1 ? 0 : xSpeed; xSpeed = Math.copySign(xSpeed * xSpeed, xSpeed); // After double xSpeed = processJoystickInput(-driverController.getLeftY()); private double processJoystickInput(double value) { value = Math.abs(value) < 0.1 ? 0 : value; // Deadband return Math.copySign(value * value, value); // Square input } Rename Variables/Methods : Use descriptive names: // Before double m = motor.get(); double v = 5.0; // After double motorOutput = motor.get(); double maxVelocityMPS = 5.0; Extract Constants : Replace magic numbers: // Before if (speed > 0.8) { ... } // After private static final double MAX_SAFE_SPEED = 0.8; if (speed > MAX_SAFE_SPEED) { ... } Consolidate Duplicate Code : // Before frontLeft.setSpeed(0.5); frontRight.setSpeed(0.5); rearLeft.setSpeed(0.5); rearRight.setSpeed(0.5); // After setAllModuleSpeeds(0.5); private void setAllModuleSpeeds(double speed) { for (SwerveModule module : modules) { module.setSpeed(speed); } } Simplify Conditionals : // Before if (isEnabled == true && hasTarget == true && inRange == true) { ... } // After if (isEnabled && hasTarget && inRange) { ... } // Even better if (canShoot()) { ... } private boolean canShoot() { return isEnabled && hasTarget && inRange; } Refactoring Subsystems Improve Organization : - Group related methods together - Separate hardware initialization - Extract complex logic to helper methods - Add clear section comments Reduce Coupling : - Avoid accessing other subsystems directly - Use commands to coordinate subsystems - Pass required objects as parameters - Use interfaces for flexibility Improve Encapsulation : - Make fields private - Provide getters/setters only as needed - Hide implementation details - Expose simple, clear methods Refactoring Commands Command Composition : Replace complex commands with composed ones: // Instead of one monolithic command public class ComplexAutoCommand extends CommandBase { // 200 lines of sequential logic } // Use composition public static Command complexAuto(subsystems...) { return Commands.sequence( new DriveToPosition(swerve, position1), new IntakeGamePiece(intake), new DriveToPosition(swerve, position2), new ScoreGamePiece(scorer) ); } Extract Reusable Commands : - Create small, focused commands - Make them reusable across autos - Use command decorators (withTimeout, andThen, etc.) Refactoring RobotContainer Extract Configuration Methods : // Instead of giant constructor public RobotContainer() { initializeSubsystems(); configureDefaultCommands(); configureButtonBindings(); configureAutonomousSelector(); } Group Related Bindings : private void configureDriverControls() { // All driver controller bindings } private void configureOperatorControls() { // All operator controller bindings } Refactoring Constants Organize by Category : public static final class DriveConstants { // All drive-related constants } public static final class IntakeConstants { // All intake-related constants } Calculate Related Constants : public static final double WHEEL_DIAMETER_METERS = 0.1016; public static final double WHEEL_CIRCUMFERENCE_METERS = WHEEL_DIAMETER_METERS * Math.PI; Safe Refactoring Process 1. Ensure Tests Pass (or code works): - Test functionality before refactoring - Document current behavior 2. Make Small Changes : - One refactoring at a time - Commit after each successful change 3. Test After Each Change : - Verify behavior unchanged - Run on robot if possible 4. Use IDE Tools : - Automated refactoring tools (rename, extract method) - Less error-prone than manual - Faster and safer 5. Get Code Review : - Have teammate review changes - Explain improvements made - Ensure clarity improved IDE Refactoring Tools (VS Code) Rename : - Right-click variable/method - Select \"Rename Symbol\" - Updates all references Extract Method : - Select code block - Right-click -> \"Refactor\" - Choose \"Extract to method\" Extract Variable : - Select expression - Right-click -> \"Refactor\" - Choose \"Extract to constant\" Red Flags to Refactor Watch for these code smells: - Methods longer than 30-40 lines - Deeply nested conditionals (>3 levels) - Duplicated code - Unclear variable names (x, temp, data) - Many parameters (>4) - Large classes (>500 lines) - Commented-out code When Not to Refactor Avoid refactoring when: - Code works and no one needs to modify it - You don't understand what it does - No tests or way to verify - Right before competition - Working on critical bugs - Time is limited Best Practices Refactor continuously, not all at once Test after each refactoring Use version control (easy to revert) Focus on readability Don't over-engineer Keep it simple Get feedback from team Document why, not just what","title":"Refactoring Code"},{"location":"Build%20Season/Updating%20Code/updatinglastyearscode/","text":"Updating Last Year's Robot Code Why Update Instead of Rewrite? Updating existing code is usually better than starting from scratch: - Faster development - Proven architecture - Known working patterns - Less risk of introducing new bugs - Team familiarity Update Strategy Phase 1: Infrastructure Updates (Week 1-2): - Update WPILib and vendor dependencies - Fix compilation errors - Update deprecated API calls - Modernize code patterns if needed Phase 2: Robot-Specific Updates (Week 2-3): - Update Constants for new robot - Modify drive code for new dimensions - Adapt odometry for new robot Phase 3: Game-Specific Features (Week 3-6): - Add new subsystems for game mechanisms - Create commands for game actions - Implement autonomous routines Phase 4: Testing and Polish (Week 6-8): - Tune PID controllers - Optimize autonomous - Fix bugs - Add safety features Updating Dependencies WPILib Update : - Install new year's WPILib - Open project in new year's VS Code - Build project - Fix any API changes Vendor Library Updates : Ctrl+Shift+P -> WPILib: Manage Vendor Libraries -> Check for updates (online) -> Update all libraries Common API Changes to Address : - Method name changes - Parameter changes - Deprecated functionality - New required imports Updating Constants.java Physical Constants : - Robot dimensions (width, length, mass) - Wheel diameter and track width - Module positions for swerve - Mechanism reach and limits CAN IDs : - Verify all device IDs match wiring - Update for new devices - Maintain consistent numbering scheme Performance Limits : - Max speeds and accelerations - Current limits - Position/velocity limits for mechanisms Control Constants : - PID gains (will need re-tuning) - Feedforward values - Motion profile constraints Updating Subsystems Drivetrain Subsystem : - Update module positions if changed - Adjust gear ratios if different - Verify motor inversions - Update odometry parameters Existing Mechanism Subsystems : - Remove if not on new robot - Keep structure if similar mechanism planned - Archive for reference New Mechanism Subsystems : - Create based on existing patterns - Follow same structure as drive subsystem - Use proven initialization patterns Updating Commands Drive Commands : - Update joystick scaling if needed - Adjust field-centric behavior - Modify any auto-align features Auto Commands : - Create new auto routines for new game - Keep framework and structure - Reuse path following logic Mechanism Commands : - Create new commands for new mechanisms - Follow existing command patterns - Use command composition Updating RobotContainer Controller Bindings : - Map new commands to buttons - Remove old game-specific bindings - Keep drive controls consistent - Add bindings for new mechanisms Autonomous Selection : - Update SendableChooser options - Add new auto routines - Remove old game-specific autos - Keep simple fallback options Updating Autonomous Path Following : - Keep existing framework - Update for new game field - Create new paths in Choreo - Test with new robot dimensions Auto Commands : - Create sequences for game tasks - Combine with new mechanism commands - Add decision logic if needed - Keep modular and reusable Code Quality Improvements While updating, also improve: - Add missing comments - Fix naming inconsistencies - Remove dead code - Improve error handling - Add logging where useful - Update unit tests Testing Strategy Incremental Testing : 1. Test after each major update 2. Verify basic functionality before moving on 3. Use simulation for initial testing 4. Test on practice robot when available 5. Validate on competition robot Test Checklist : - [ ] Code builds without errors - [ ] Drive system operates correctly - [ ] All motors spin correct direction - [ ] Sensors read correctly - [ ] Commands execute as expected - [ ] Autonomous routines work - [ ] Safety limits function - [ ] Dashboard displays data Version Control Best Practices Branching Strategy : - Create feature branches for major changes - Use pull requests for code review - Keep main branch stable - Tag important milestones Commit Messages : - Describe what and why - Reference issues if applicable - Use consistent format - Make commits atomic Documentation Updates Update documentation to reflect changes: - README with new features - Code comments for complex logic - Setup instructions - Known issues - Testing procedures Common Pitfalls Scope Creep : - Resist urge to rewrite everything - Focus on necessary updates first - Add features incrementally - Keep it simple initially Breaking Changes : - Test thoroughly after updates - Don't update everything at once - Keep working backup - Document what changed Premature Optimization : - Get it working first - Optimize based on actual needs - Don't over-engineer early - Profile before optimizing Best Practices Update incrementally, test frequently Keep team informed of changes Use code reviews Maintain backward compatibility when possible Document breaking changes Keep old code as reference Plan updates before starting Communicate with other subteams","title":"Updating Last Year's Robot Code"},{"location":"Build%20Season/Updating%20Firmware/retrainingcoral/","text":"Retraining Google Coral Neural Networks What is the Google Coral? The Google Coral USB Accelerator is an AI hardware accelerator that plugs into the Limelight 3 to run neural networks for custom object detection (game pieces, field elements, etc.). When to Retrain Neural Networks Retrain when: - New game requires different object detection - Existing model not detecting accurately - Lighting conditions change significantly - Game piece design changes - Adding new detection classes - Improving detection confidence Training Process Overview The neural network training pipeline: 1. Collect training images 2. Label images with bounding boxes 3. Train model using TensorFlow/PyTorch 4. Convert to Edge TPU format 5. Upload to Limelight 6. Test and iterate Collecting Training Data Image Collection Best Practices : - Variety : Multiple angles, distances, lighting - Quantity : 500-2000+ images per class - Conditions : Match competition environment - Backgrounds : Include field elements - Orientations : Objects in various positions Collection Methods : - Limelight snapshot feature - Manual photography - Video frame extraction - Team-shared datasets (Chief Delphi) Labeling Images Use labeling tools like: - Roboflow : Web-based, easy to use - CVAT : Open source, powerful - LabelImg : Desktop application For each image: - Draw bounding boxes around objects - Assign correct class labels - Verify accuracy - Export in compatible format (COCO, Pascal VOC) Training Models Option 1: Limelight Training Pipeline : - Upload labeled dataset to Limelight - Use Limelight's cloud training service - Automatic conversion to Edge TPU format - Simple but less control Option 2: Google Colab/Custom Training : - Use TensorFlow or PyTorch - Train on Google Colab (free GPU) - More control over model architecture - Requires ML expertise Option 3: Roboflow Training : - Upload to Roboflow - Train in cloud - Export for Edge TPU - User-friendly interface Model Conversion To run on Google Coral: - Model must be TensorFlow Lite format - Compiled for Edge TPU - Quantized (INT8) - Optimized for inference speed Use Edge TPU Compiler: edgetpu_compiler model.tflite Uploading to Limelight 1. Access Limelight Web Interface : - Navigate to http://limelight.local:5801/ 2. Go to Neural Network Tab : - Select neural network pipeline 3. Upload Model : - Choose compiled .tflite file - Upload labels file (.txt) - Configure detection parameters 4. Configure Pipeline : - Set confidence threshold - Adjust detection regions - Configure output format Testing and Validation After uploading model: - Test with real objects : Verify detection - Check confidence scores : Should be >70% - Test in various lighting : Match competition - Measure inference time : Should be <50ms - Test at competition distances : Realistic range - Check false positives : Minimize incorrect detections Iteration and Improvement If model isn't accurate: - Collect more training images (especially missed cases) - Add more variety to training data - Adjust model architecture - Fine-tune detection threshold - Add hard-negative examples (false positives) - Retrain with augmented data Integration with Robot Code Access neural network results in code: // Get neural network detections LimelightResults results = LimelightHelpers.getLatestResults(\"limelight\"); Detector[] detectors = results.targetingResults.detector_results; for (Detector detector : detectors) { String className = detector.className; double confidence = detector.confidence; double[] bbox = detector.bbox; // [x, y, width, height] } Best Practices Start training early in build season Collect diverse training data Test on actual robot/field Keep training data organized Document model versions and performance Have fallback detection methods Practice switching between pipelines Test in pit and match conditions Resources Limelight neural network docs: https://docs.limelightvision.io/ TensorFlow Lite: https://www.tensorflow.org/lite Edge TPU Compiler: https://coral.ai/docs/edgetpu/compiler/ Roboflow: https://roboflow.com/ FRC ML resources on Chief Delphi Competition Considerations Have multiple trained models ready Test models before each match Monitor detection confidence Have non-neural-network fallback Don't rely solely on neural detection Document which model is being used","title":"Retraining Google Coral"},{"location":"Build%20Season/Updating%20Firmware/updatingcancoders/","text":"Updating CANCoder Firmware What are CANCoders? CANCoders are CTRE absolute magnetic encoders used to measure rotational position. They're critical for swerve drive steering and other mechanisms that need to know their exact angle. When to Update CANCoder Firmware Update CANCoder firmware: - At start of build season - When Phoenix 6 firmware is released - Before competitions - When adding new CANCoders - If experiencing position reading issues Prerequisites Phoenix Tuner X installed and updated Robot powered with 12V battery USB or CAN connection to robot All CANCoders have unique CAN IDs Magnets properly positioned near CANCoders Update Process 1. Connect to Robot : - Power robot with 12V battery - Connect computer via USB or network - Launch Phoenix Tuner X 2. Discover Devices : - Click scan/refresh in Tuner X - All CANCoders appear in device list - Note current firmware versions 3. Update Firmware : - Select CANCoder to update - Click \"Update Firmware\" button - Choose latest Phoenix 6 firmware - Confirm update - Wait for completion (30-60 seconds) - Don't disconnect during update! 4. Repeat for All CANCoders : - Update one device at a time - Verify each update before moving to next - Test position reading after each update 5. Verify Updates : - Check firmware versions match - Test position readings - Verify configurations retained CANCoder Configuration After firmware update, verify: - CAN ID is correct - Magnet offset configured - Update rate appropriate - Direction correct (clockwise/counter-clockwise) - Units set (degrees/radians/rotations) - Absolute vs relative mode Important : Firmware updates may reset some configurations! Testing CANCoder Position After updating, test each CANCoder: - Rotate mechanism slowly - Watch position value change - Verify 0-360\u00b0 range (or 0-1 rotation) - Check position stays consistent - Test at different speeds - Verify absolute position retained after power cycle Phoenix 6 vs Phoenix 5 CANCoders work with both: - Phoenix 5 : Older API, stable - Phoenix 6 : New API, better features Choose based on your codebase. Phoenix 6 recommended for new projects. Magnet Alignment For accurate readings: - Magnet must be centered over CANCoder - Distance: 2-5mm ideal - Magnet must be diametrically polarized - Check LED on CANCoder: - Green : Good magnet strength - Orange : Marginal - Red : Bad alignment or no magnet Troubleshooting Can't detect CANCoder : - Check power (LED should light) - Verify CAN wiring - Check CAN termination resistor - Try different device first - Ensure magnet present (LED should be green/orange) Update fails : - Ensure stable 12V power - Check CAN bus connections - Update Tuner X first - Try one device at a time - Check for CAN bus errors Position reading wrong : - Verify magnet alignment (green LED) - Re-calibrate offset - Check configuration (direction, units) - Verify position source in code - Test with known good magnet Position drifts or jumps : - Check magnet distance and alignment - Verify CAN bus not overloaded - Check for electrical interference - Test at lower update rates - Ensure firmware versions match Swerve Drive Considerations For swerve modules: - Update all CANCoders before tuning offsets - Document offset values (in case reset) - Test wheel straight position after update - Re-run offset calibration if needed - Verify all modules report correct angles Best Practices Update all CANCoders to same firmware Test magnet alignment before updating Document offset values before updating Update during robot development, not at competition Keep spare CANCoder configured Label CANCoders with CAN ID","title":"Updating CANCoders"},{"location":"Build%20Season/Updating%20Firmware/updatinglimelight/","text":"Updating Limelight Firmware When to Update Limelight Firmware Update Limelight firmware: - At start of build season - When new features are released - Before major competitions - If experiencing vision issues - When updating Google Coral neural networks Prerequisites Limelight Hardware Manager installed Limelight powered and connected Stable internet connection (for firmware download) Backup of current pipeline configurations Checking Current Firmware Method 1: Web Interface : - Navigate to http://limelight.local:5801/ - Check firmware version on homepage - Note version number Method 2: Hardware Manager : - Launch Limelight Hardware Manager - Connect to Limelight - View firmware version in device info Update Process 1. Backup Configuration : - Open Limelight web interface - Go to Settings tab - Download pipeline backup - Save to safe location 2. Connect to Limelight : - Ensure Limelight has stable power - Connect via USB-C, Ethernet, or WiFi - Launch Limelight Hardware Manager 3. Start Update : - Select Limelight in device list - Click \"Update Firmware\" - Select latest available version - Confirm update 4. Wait for Update : - Download and installation (5-10 minutes) - Limelight will reboot automatically - Status LED will indicate progress - Don't disconnect power or network! 5. Verify Update : - Limelight reboots and shows new version - Check web interface accessible - Verify pipelines still configured - Test vision processing Restore Configuration If settings were reset: - Open web interface - Go to Settings tab - Upload pipeline backup - Verify pipeline settings - Test with targets Testing After Update Verify Limelight operation: - AprilTag detection : Point at tags, check detection - Neural network : Test game piece detection (if using) - LED control : Test LED modes - Streaming : Check video stream - NetworkTables : Verify data publishing - Pose estimation : Test MegaTag/MegaTag2 Limelight 3 Specific Features After updating, check new features: - Dual camera support - MegaTag2 improvements - Python scripting updates - New neural network capabilities - Improved pose estimation Google Coral Compatibility If using Google Coral: - Verify neural network models still load - Re-train/re-upload if model format changed - Test detection accuracy - Check inference speed Common Issues After Update Web interface not loading : - Wait longer (Limelight may still be booting) - Check network connection - Try http://10.TE.AM.11/ (team number based) - Power cycle Limelight - Check Ethernet cable Pipelines reset : - Restore from backup - Recreate pipelines if no backup - Document pipeline settings going forward Vision not working : - Check camera focused - Verify correct pipeline selected - Test with known targets - Check LED control - Review pipeline settings NetworkTables data missing : - Verify robot code compatible with firmware - Check NetworkTables connection - Update LimelightHelpers.java if needed - Restart robot code Multiple Limelights If running multiple Limelights: - Update one at a time - Test each before updating next - Use descriptive names (limelight-front, limelight-back) - Verify network configuration for each - Update LimelightHelpers calls in code Firmware Version Selection Limelight firmware options: - Latest Release : Stable, recommended - Beta : New features, may be unstable - Specific versions : For known-good configurations For competitions, use latest release version. Best Practices Update early in build season Always backup pipelines first Test thoroughly after updating Don't update right before competition Document firmware version used Keep spare Limelight with old firmware (if needed) Update all Limelights to same version Test in competition-like conditions SD Card Re-imaging If update fails completely: - Download latest Limelight image - Use BalenaEtcher to flash SD card - Insert into Limelight - Power on and configure from scratch - Restore pipelines from backup","title":"Updating Limelight"},{"location":"Build%20Season/Updating%20Firmware/updatingpdh/","text":"Updating PDH Firmware What is the PDH? The REV Power Distribution Hub (PDH) distributes power from the battery to all robot components while providing current monitoring for each channel. Keeping its firmware updated ensures reliable operation and access to new features. When to Update PDH Firmware Update PDH firmware: - At start of build season - When firmware updates are released - Before competitions - If experiencing power issues - When adding PDH to robot Prerequisites REV Hardware Client 2 installed Robot powered with 12V battery USB or CAN connection to robot PDH properly wired and connected Update Process 1. Connect to Robot : - Install charged 12V battery - Connect main breaker - Connect computer via USB to SystemCore/RoboRIO - Ensure PDH is powered (check LEDs) 2. Launch REV Hardware Client : - Open REV Hardware Client 2 - Wait for device discovery - PDH appears in device list 3. Select PDH : - Click on PDH in device list - View current firmware version - Check if update available 4. Update Firmware : - Click firmware version indicator - Select latest firmware version - Click \"Update Firmware\" - Wait for update (1-2 minutes) - Critical: Don't disconnect power! 5. Verify Update : - Check new firmware version displayed - Observe PDH status LED - Test channel monitoring - Verify robot operates normally PDH Configuration Settings After firmware update, verify: - CAN ID (default is 1, usually unchanged) - Switchable channel states - Current monitoring working - Voltage reading accurate Testing After Update Verify PDH operation: - Check voltage reading (should be ~12V) - Monitor current on active channels - Test switchable channels - Verify all devices have power - Check for fault indicators PDH Status Indicators Status LED : - Green : Normal operation - Red : Fault condition - Orange/Yellow : Warning - Blinking : Various states Channel LEDs : - Individual LEDs show which channels are active - Useful for troubleshooting power issues Common Issues After Update PDH not detected : - Check CAN bus connections - Verify PDH has power - Check CAN termination - Try restarting REV Hardware Client Update fails : - Ensure battery is charged (>11V) - Check stable USB/CAN connection - Don't run motors during update - Try again with less electrical load Channels not working : - Check breakers (may have tripped) - Verify wiring connections - Reset breakers - Check current limits not exceeded Monitoring and Diagnostics Use REV Hardware Client to: - View real-time current draw per channel - Monitor total current consumption - Check voltage under load - Identify high-current devices - Detect intermittent issues This data is valuable for: - Optimizing power distribution - Identifying electrical problems - Planning battery management - Competition preparation Best Practices Update PDH first (before other devices) Verify update before updating other hardware Document firmware version used Test thoroughly after updating Keep spare PDH configured and ready Monitor current draw regularly Don't update right before matches PDH vs PDP The PDH replaces the older CTRE Power Distribution Panel (PDP): - More channels (20 vs 16 high-current) - Better current monitoring - CAN communication - Switchable channels - Integrated to REV ecosystem","title":"Updating PDH"},{"location":"Build%20Season/Updating%20Firmware/updatingrobotradio/","text":"Updating Robot Radio Firmware What is the Robot Radio? The robot radio is the OpenMesh OM5P-AN or OM5P-AC wireless access point that provides communication between the driver station and robot. It must be properly configured and updated for FRC use. When to Update Radio Update/configure radio: - At start of build season - When bringing new radio into service - If radio firmware is outdated - Before competition (verify configuration) - After radio factory reset Required Tools FRC Radio Configuration Utility (part of FRC Game Tools) Ethernet cable Robot radio with power supply or PoE 12V power supply or robot battery Radio Programming Steps 1. Connect Radio : - Connect radio to 12V power or PoE injector - Connect Ethernet from computer to radio's 18-24v PoE port - Wait for radio to boot (about 30 seconds) 2. Launch FRC Radio Configuration Utility : - Open from Start Menu - Should detect radio automatically 3. Configure Radio : - Select radio from list - Enter team number (e.g., 8533) - Choose firmware version: - FRC Configuration : Competition use (5 GHz only) - 2.4 GHz AP : Practice/pit use - Click \"Configure\" 4. Wait for Programming : - Process takes 3-5 minutes - Don't disconnect during programming - Radio will reboot when complete 5. Verify Configuration : - Radio status LEDs should be solid - Can connect to robot network - Team number appears in SSID Radio LED Status Understanding LED patterns: - Solid LEDs : Radio configured and working - Blinking LEDs : Radio booting or updating - No LEDs : Check power connection Radio Network Settings After configuration: - SSID : FRC_XXXX (XXXX = team number) - Robot IP : 10.TE.AM.2 (e.g., 10.85.33.2) - Driver Station : 10.TE.AM.5 - 5 GHz band : For competition - 2.4 GHz band : For practice (if configured) Troubleshooting Can't detect radio : - Check power (LEDs should be on) - Verify Ethernet connection - Try different Ethernet port - Disable WiFi on computer - Check firewall settings Programming fails : - Try different Ethernet cable - Ensure stable power - Close other networking programs - Try factory reset first - Use different computer Radio not working after programming : - Verify correct team number entered - Check robot IP addressing - Try 2.4 GHz mode for testing - Re-program radio - Contact FTA if at competition Best Practices Program radios well before competition Label radios with team number Keep spare programmed radio Document radio settings Test radio range before comp Secure radio mounting on robot","title":"Updating Robot Radio"},{"location":"Build%20Season/Updating%20Firmware/updatingsparkmaxes/","text":"Updating SPARK MAX Firmware When to Update SPARK MAX Firmware Update SPARK MAX firmware: - At start of build season - When new firmware is released - Before competitions - When adding new SPARK MAXes - If experiencing control issues Prerequisites REV Hardware Client 2 installed and updated Robot powered with 12V battery USB or CAN connection to robot All SPARK MAXes have unique CAN IDs Update Process 1. Connect to Robot : - Power robot with 12V battery - Connect computer via USB or SystemCore/RoboRIO - Ensure CAN bus is properly terminated 2. Launch REV Hardware Client : - Open REV Hardware Client 2 - Wait for device discovery - SPARK MAXes appear in device list 3. Check Current Firmware : - Select each SPARK MAX - Note current firmware version - Compare to latest available 4. Update Firmware : - Select SPARK MAX to update - Click firmware version indicator - Choose latest firmware version - Click \"Update Firmware\" - Wait for update (30-60 seconds per device) - Don't disconnect or power off! 5. Verify Update : - Check new firmware version - Test motor briefly (if safe) - Repeat for all SPARK MAXes Bulk Update Strategy For teams with many SPARK MAXes: - Update by subsystem (all drive, then intake, etc.) - Test each subsystem after updating - Document which devices updated - Keep one subsystem at old firmware for comparison Configuration After Update After firmware update, verify: - CAN ID still correct - Motor type setting (NEO, NEO 550) - Current limits appropriate - Idle mode (brake/coast) - PID values (may reset) - Sensor feedback configured Some settings may reset during firmware update! Testing After Update Test each SPARK MAX: - Motor spins in correct direction - Current draw is reasonable - No error LEDs (should be cyan/solid) - Responds to commands properly - PID control works correctly SPARK MAX Status LEDs LED color meanings: - Cyan/Magenta : Normal operation - Blinking Red : Fault condition - Blinking Cyan/Magenta : Updating firmware - No LED : No power or dead device Troubleshooting Can't see SPARK MAX : - Check power (green power LED) - Verify CAN wiring - Check CAN termination - Try different device first - Restart REV Hardware Client Update fails : - Ensure stable power (battery charged) - Check USB/CAN connection - Try updating one at a time - Update REV Hardware Client - Contact REV support if persistent Motor doesn't work after update : - Re-configure motor type - Check current limits - Restore PID values - Verify CAN ID - Check motor connections - Try rolling back firmware Version Compatibility Ensure compatibility between: - SPARK MAX firmware - REV Hardware Client version - REVLib version in robot code - SystemCore/RoboRIO firmware Mismatched versions can cause issues! Best Practices Update all devices at same time Keep spare SPARK MAX with current firmware Document firmware versions used Test thoroughly after updating Don't update right before competition Back up configurations before updating","title":"Updating SPARK MAXes"},{"location":"Build%20Season/Updating%20Firmware/updatingsystemcore/","text":"Updating SystemCore Firmware What is SystemCore? SystemCore is the next-generation FRC robot controller that will replace the NI RoboRIO starting in 2027. It features more processing power, modern interfaces, and improved capabilities. When to Update SystemCore Firmware Update firmware: - At start of build season - When FRC releases firmware updates - Before competitions - When troubleshooting issues - After SD card re-imaging Prerequisites Before updating: - Download latest SystemCore firmware from NI/FRC - Have working SD card (or backup) - SystemCore powered and connected - Stable internet connection - Latest WPILib installed Update Methods Method 1: WPILib Imaging Tool : 1. Launch FRC VS Code 2. Press Ctrl+Shift+P 3. Type \"WPILib: Imaging Tool\" 4. Select SystemCore 5. Choose latest firmware 6. Follow prompts to update Method 2: Web Interface : 1. Connect to SystemCore via Ethernet 2. Navigate to http://systemcore-XXXX.local/ (XXXX = team number) 3. Go to firmware update page 4. Upload firmware file 5. Wait for update and reboot Method 3: SD Card Re-imaging : 1. Download SystemCore image 2. Use BalenaEtcher to flash SD card 3. Insert SD card into SystemCore 4. Power on and wait for boot Verification After updating: - Check firmware version in web interface - Test robot code deployment - Verify all devices detected - Test basic robot functions - Check for error messages Important Notes SystemCore replaces RoboRIO in 2027 Requires updated robot code Different pinout than RoboRIO New features and capabilities Backward compatibility considerations Troubleshooting Update fails : - Check power supply (stable 12V) - Verify network connection - Try different update method - Re-image SD card if persistent SystemCore won't boot : - Check SD card is inserted - Try known-good SD card - Check power connections - Look for status LED patterns","title":"SystemCore"},{"location":"Build%20Season/Updating%20Software/installingfrcgametools/","text":"Installing FRC Game Tools What are FRC Game Tools? FRC Game Tools is a Windows-only software package from National Instruments that includes: - FRC Driver Station (required for controlling robot) - FRC Radio Configuration Utility - SystemCore/RoboRIO Imaging Tool - Documentation and examples When to Install/Update Install Game Tools: - At the start of build season - On driver station laptops - When setting up new computers - After major updates are announced Installation Steps 1. Download Installer : - Go to https://www.ni.com/en-us/support/downloads/drivers/download.frc-game-tools.html - Or search for \"FRC Game Tools\" on ni.com - Download the current season's version - File size is typically 1-2 GB 2. Run Installer : - Extract downloaded ZIP file - Run the installer executable - Accept license agreement - Choose installation directory (use default) - Wait for installation (can take 15-30 minutes) 3. Activate Software (if required): - Some years require activation - Use provided serial number or activation code - Follow on-screen instructions 4. Verify Installation : - Launch \"FRC Driver Station\" - Should open without errors - Check version number matches current season Driver Station Laptop Requirements The computer running Driver Station must: - Run Windows 10 or 11 (64-bit) - Have at least 4GB RAM (8GB recommended) - Have available USB ports for controllers - Have Ethernet port or USB-to-Ethernet adapter - Be dedicated to driving (close other programs) First-Time Setup After installation: - Set team number in Driver Station - Configure controller USB devices - Test communication with robot - Set up practice mode timer - Configure dashboard (Shuffleboard, Elastic, etc.) Important Notes Windows only : Driver Station doesn't run on Mac/Linux One instance per network : Only one Driver Station can control robot Updates throughout season : Check for updates regularly Backup laptop : Have spare laptop with Game Tools installed Battery life : Keep driver station laptop plugged in during matches Troubleshooting Common issues: - Installation fails: Check disk space and permissions - Driver Station won't open: Reinstall FRC Game Tools - Can't see robot: Check network settings and firewall - Controllers not detected: Use USB tab to configure","title":"Installing FRC Game Tools"},{"location":"Build%20Season/Updating%20Software/installingwpilib/","text":"Installing WPILib What is WPILib? WPILib is the complete software package for FRC robot programming. It includes: - Visual Studio Code configured for FRC - Java Development Kit (JDK) - WPILib libraries and tools - Vendor library management - Robot simulation tools - Documentation and examples When to Install/Update Install WPILib: - At the start of build season (early January) - When joining the programming team - After major updates are released Always use the version released for the current season. Installation Steps 1. Download Installer : - Go to https://docs.wpilib.org/ - Navigate to \"Zero to Robot\" \u2192 \"Installation\" - Download the appropriate installer for your OS (Windows, Mac, Linux) 2. Run Installer : - Extract the downloaded file - Run WPILibInstaller.exe (Windows) or appropriate installer - Choose \"Install for this User\" (recommended) - Select components to install (use defaults) - Choose installation directory - Click Install 3. Verify Installation : - Launch \"FRC VS Code 2024\" (or current year) - Press Ctrl+Shift+P - Type \"WPILib\" - should see WPILib commands - Create a test project to verify everything works Important Notes Don't uninstall old versions until new season code is stable Each year has separate installation (e.g., FRC VS Code 2024, 2025) Installation is per-user , not system-wide Offline installer available for competitions without internet Document which version you're using for team consistency Post-Installation Setup After installing: - Set up vendor dependencies (REV, CTRE, etc.) - Configure Git in VS Code - Clone team repositories - Verify robot deployment works - Test simulation Troubleshooting Common installation issues: - Antivirus blocking installer: Add exception - Insufficient permissions: Run as administrator - Previous incomplete installation: Manually remove old files first - Wrong Java version: WPILib includes correct JDK","title":"Installingwpilib"},{"location":"Build%20Season/Updating%20Software/updatingbalenaetcher/","text":"Updating BalenaEtcher What is BalenaEtcher? BalenaEtcher is a free, cross-platform tool for writing disk images to SD cards and USB drives. In FRC, it's used for: - Imaging SystemCore SD cards - Creating bootable SD cards for recovery - Flashing Limelight SD cards - Backing up and restoring system images When to Update Update BalenaEtcher: - At start of build season - If you encounter imaging errors - When new version is released - Before imaging critical hardware Installation 1. Download : - Visit https://www.balena.io/etcher/ - Click \"Download\" button - Choose version for your OS: - Windows: .exe installer - Mac: .dmg installer - Linux: AppImage or .deb 2. Install : - Windows : Run .exe and follow installer - Mac : Open .dmg and drag to Applications - Linux : Make AppImage executable or install .deb package 3. Launch : - Open BalenaEtcher from applications menu - May require administrator/sudo permissions Using BalenaEtcher Basic Imaging Process : 1. Select Image : Click \"Flash from file\" and choose image file (.img, .zip, etc.) 2. Select Target : Click \"Select target\" and choose SD card/USB drive 3. Flash : Click \"Flash!\" and wait for completion 4. Validate : Etcher automatically validates after writing Important Safety Notes : - Double-check target drive : Etching overwrites all data! - Don't interrupt : Wait for validation to complete - Safely eject : Use OS eject function after completion - Keep backup : Always have spare SD cards ready Common Use Cases in FRC SystemCore Imaging : - Download SystemCore image from NI - Flash to microSD card for SystemCore - Follow WPILib imaging documentation Limelight SD Card : - Download Limelight image from limelightvision.io - Flash to microSD card - Insert into Limelight and power on Backup and Recovery : - Create image backups of working systems - Quickly restore if problems occur - Keep known-good images for competitions Troubleshooting Etcher won't detect drive : - Try different USB port - Try different card reader - Check if card is write-protected - Format card first (if needed) Flash fails : - Download image file again (may be corrupted) - Try different SD card - Check available disk space - Run Etcher as administrator/sudo Validation fails : - Card may be defective - Try different card reader - Use slower USB port (USB 2.0) - Check card compatibility Best Practices Use high-quality SD cards (SanDisk, Samsung) Keep Etcher updated Always validate after flashing Label imaged cards clearly Keep spare pre-imaged cards Document image versions used Test imaged devices before competition","title":"Updating BalenaEtcher"},{"location":"Build%20Season/Updating%20Software/updatingchoreo/","text":"Updating Choreo What is Choreo? Choreo is a trajectory optimization and path planning tool for FRC autonomous routines. It helps create smooth, fast, and collision-free paths for swerve drive robots. When to Update Update Choreo: - At start of build season - When new features are released - If experiencing bugs - Before finalizing autonomous routines Installation/Update Process 1. Download Latest Version : - Visit https://github.com/SleipnirGroup/Choreo/releases - Find latest release - Download appropriate installer: - Windows: .exe or .msi - Mac: .dmg - Linux: .AppImage or .deb 2. Install : - Windows : Run installer, follow prompts - Mac : Open .dmg, drag to Applications - Linux : Install package or run AppImage 3. Verify Installation : - Launch Choreo - Check Help \u2192 About for version number - Open existing project to test Updating Project Files When updating Choreo: - Backup projects before updating - Test projects after update - Regenerate trajectory exports if file format changed - Update robot code if API changed Choreo Project Structure Choreo projects contain: - Robot configuration (dimensions, constraints) - Multiple trajectories - Waypoints and control points - Export settings Projects are stored as files you can version control. Key Features to Configure Robot Configuration : - Robot width and length - Module positions - Max velocity and acceleration - Max angular velocity - Wheel radius and gear ratios Path Configuration : - Waypoints with constraints - Starting/ending velocities - Maximum velocity zones - Obstacle avoidance Export Settings : - File format (WPILib compatible) - Output directory - Coordinate system Integration with Robot Code After creating paths in Choreo: 1. Export trajectories 2. Place in src/main/deploy/choreo/ directory 3. Load in robot code using Choreo.getTrajectory(name) 4. Create command to follow trajectory 5. Test in simulation first Best Practices Version control Choreo project files Use descriptive names for paths Test paths in simulation before robot Document constraints used Keep backup of working configurations Share project files with team Troubleshooting Paths won't generate : - Check robot configuration - Reduce max velocity/acceleration - Adjust waypoint constraints - Check for impossible paths Export fails : - Verify output directory exists - Check file permissions - Update to latest Choreo version Robot doesn't follow path : - Verify odometry is accurate - Check PID tuning - Confirm trajectory file loaded correctly - Validate starting position","title":"Updating Choreo"},{"location":"Build%20Season/Updating%20Software/updatinglimelighthardwaremanager/","text":"Updating Limelight Hardware Manager What is Limelight Hardware Manager? Limelight Hardware Manager is a desktop application for managing Limelight smart cameras. It provides: - Firmware updates - SD card imaging - Network configuration - Device discovery - Configuration backup/restore When to Update Update Limelight Hardware Manager: - At start of build season - Before updating Limelight firmware - When troubleshooting Limelight issues - When new features are released Installation 1. Download : - Visit https://limelightvision.io/pages/downloads - Scroll to \"Limelight Hardware Manager\" - Download for your OS: - Windows: .exe installer - Mac: .dmg installer - Linux: .AppImage 2. Install : - Windows : Run .exe installer - Mac : Open .dmg, drag to Applications - Linux : Make AppImage executable 3. Launch : - Open Limelight Hardware Manager - Allow network permissions if prompted Connecting to Limelight Discovery Methods : - USB-C : Direct connection to computer - Ethernet : Connect via robot network - WiFi : Connect to Limelight's WiFi hotspot Connection Steps : 1. Power on Limelight (via PoE, USB-C, or barrel jack) 2. Connect computer to same network 3. Launch Hardware Manager 4. Click \"Scan\" or \"Refresh\" 5. Limelight appears in device list Updating Limelight Firmware Check Current Version : - Select Limelight in device list - View current firmware version - Compare to latest available Update Process : 1. Ensure stable power and connection 2. Click \"Update Firmware\" 3. Select latest firmware version 4. Wait for download and installation (5-10 minutes) 5. Limelight will reboot automatically 6. Verify new firmware version Important Notes : - Don't disconnect during update - Stable internet required for download - Update may take several minutes - Limelight reboots automatically when complete SD Card Imaging If Limelight needs complete re-imaging: 1. Download latest Limelight image from website 2. Use BalenaEtcher to flash image to SD card 3. Insert SD card into Limelight 4. Power on Limelight 5. Wait for boot (LED will pulse) 6. Connect and verify operation Configuration Management Backup Configuration : - Select Limelight - Click \"Backup Configuration\" - Save file to safe location - Include in version control Restore Configuration : - Select Limelight - Click \"Restore Configuration\" - Choose backup file - Wait for restoration Use Cases : - Before major changes - When replacing Limelight - Sharing configurations between cameras - Disaster recovery Network Configuration Hardware Manager can configure: - Static IP address - Team number - Network mode (DHCP vs Static) - WiFi hotspot settings Troubleshooting Can't find Limelight : - Check power (green status LED) - Verify network connection - Try USB-C direct connection - Check firewall settings - Restart Hardware Manager Firmware update fails : - Check internet connection - Try direct USB-C connection - Ensure stable power - Wait and retry - Try SD card re-imaging if persistent Connection drops during update : - Don't panic - Limelight may recover - Wait 5 minutes - Power cycle if unresponsive - May need SD card re-imaging","title":"Updating Limelight Hardware Manager"},{"location":"Build%20Season/Updating%20Software/updatingphoenixtunerx/","text":"Updating Phoenix Tuner X What is Phoenix Tuner X? Phoenix Tuner X is CTRE's next-generation configuration tool for Phoenix 6 devices: - CANCoders (absolute encoders) - TalonFX motor controllers - Pigeon 2.0 IMU - CANdle LED controller - CANcoder encoders Phoenix Tuner X replaces the older Phoenix Tuner v1. When to Update Update Phoenix Tuner X: - At start of build season - When new firmware is released - Before major competitions - When new features are needed Installation Download and Install : - Visit https://v6.docs.ctr-electronics.com/ - Navigate to Tuner documentation - Download for your OS (Windows, Mac, Linux) - Run installer and follow prompts Or via WinGet (Windows) : winget install CTRE.PhoenixTunerX Initial Setup 1. Launch Phoenix Tuner X : - Open from Start Menu or Applications 2. Connect to Robot : - USB connection to SystemCore/RoboRIO - Or over network (Ethernet/WiFi) - Robot must be powered 3. Detect Devices : - Click scan or refresh - All CTRE devices appear in device list Updating Firmware Check Current Versions : - View firmware version for each device - Compare to latest available firmware Update Process : 1. Select device to update 2. Click \"Update Firmware\" button 3. Choose latest version 4. Wait for update to complete 5. Verify new version installed 6. Repeat for all devices Important : - Update SystemCore/RoboRIO firmware first - Then update all other devices - Test after each update batch Configuration Features Swerve Project Generator : - Automatically generates swerve drive code - Configures module constants - Creates TunerConstants.java file - Simplifies swerve setup Device Configuration : - Set CAN IDs - Configure PID gains - Set current limits - Configure feedback sensors - Save configurations to devices Plotting and Diagnostics : - Real-time signal plotting - View CAN bus utilization - Monitor device status - Debug control loops Phoenix 6 vs Phoenix 5 Phoenix 6 (Tuner X) features: - Better API design - Improved performance - More features - Requires license for some features - Not compatible with Phoenix 5 devices Teams should use Phoenix 6 for new projects. Licensing Phoenix 6 has two tiers: - Free tier : Basic functionality - Pro tier : Advanced features (CANivore, SignalLogging, etc.) - Purchase season license if needed Troubleshooting Connection issues: - Verify robot is on and connected - Check firewall settings - Try USB connection if network fails - Update Tuner X to latest version - Check CTRE documentation for known issues","title":"Updating Phoenix Tuner X"},{"location":"Build%20Season/Updating%20Software/updatingrevhardwareclient2/","text":"Updating REV Hardware Client 2 What is REV Hardware Client? REV Hardware Client is a desktop application for configuring, updating, and testing REV Robotics hardware including: - SPARK MAX motor controllers - Power Distribution Hub (PDH) - Pneumatic Hub - Color Sensor V3 - Through Bore Encoders When to Update Update REV Hardware Client: - At the start of build season - When firmware updates are released - Before competitions - When troubleshooting hardware issues Downloading and Installing 1. Download : - Visit https://docs.revrobotics.com/rev-hardware-client/ - Click \"Download\" button - Choose version for your OS (Windows, Mac, Linux) 2. Install : - Run downloaded installer - Follow installation wizard - Launch REV Hardware Client 2 3. Check for Updates : - Open REV Hardware Client - Check Help menu for software updates - Install any available updates Using REV Hardware Client Connect to Devices : - Connect robot via USB or CAN - Power on robot (12V battery) - Devices appear in left sidebar Update Firmware : - Select device from list - Click firmware version indicator - Choose latest firmware - Click \"Update Firmware\" - Wait for completion (don't disconnect!) Configure Devices : - Set CAN IDs - Configure motor parameters - Set current limits - Test motors safely - Save configurations Firmware Update Best Practices Update all devices at start of season Verify firmware versions match across all devices Test after updating to ensure proper operation Document firmware versions used Don't update right before competition unless critical fix One device at a time to prevent issues Troubleshooting Connection Issues If devices don't appear: - Check robot is powered on - Verify USB or CAN connection - Try different USB port or cable - Check device has power (green LED) - Restart REV Hardware Client - Check CAN termination resistor - Verify CAN bus wiring Important Features Network Tab : - View all devices on CAN bus - Identify conflicts (duplicate IDs) - Check device health Motor Test Tab : - Safely test motors - Verify proper direction - Check current draw - Identify mechanical issues Firmware Recovery : - Recover bricked devices - Force firmware update mode - Contact REV support if needed","title":"Updating Rev Hardware Client 2"},{"location":"I%27m%20New%20Here/Codebase%20Overview/autosjava/","text":"Autos.java What is Autos.java? Autos.java is a utility class that organizes and creates autonomous routines. It typically: - Imports trajectories from Choreo or PathPlanner - Creates auto command groups - Provides methods for RobotContainer to access autos - Defines named commands for path following Typical Structure public class Autos { // Private constructor - only static methods private Autos() {} // Create autonomous commands public static Command exampleAuto(SwerveSubsystem swerve, IntakeSubsystem intake) { return Commands.sequence( // Reset odometry to starting position Commands.runOnce(() -> swerve.resetOdometry(startingPose)), // Follow path followChoreoPath(swerve, \"ExamplePath\"), // Run intake new IntakeCommand(intake).withTimeout(2.0), // Follow another path followChoreoPath(swerve, \"ReturnPath\") ); } // Helper method for Choreo paths private static Command followChoreoPath(SwerveSubsystem swerve, String pathName) { ChoreoTrajectory traj = Choreo.getTrajectory(pathName); return Choreo.choreoSwerveCommand( traj, swerve::getPose, // PID controllers new PIDController(5.0, 0.0, 0.0), // X new PIDController(5.0, 0.0, 0.0), // Y new PIDController(3.0, 0.0, 0.0), // Rotation swerve::setModuleStates, swerve ); } } Organizing Autonomous Routines Simple Autos : - Single path following - Basic sequences (drive, shoot, drive back) Complex Autos : - Multiple paths - Parallel command groups (intake while driving) - Conditional logic (if see target, then...) - Dynamic path selection Integration with Choreo Choreo trajectories are loaded by name: ChoreoTrajectory trajectory = Choreo.getTrajectory(\"FourNoteAuto\"); Path files are stored in src/main/deploy/choreo/ directory. Named Commands For PathPlanner integration, register named commands: NamedCommands.registerCommand(\"Intake\", new IntakeCommand(intake)); NamedCommands.registerCommand(\"Shoot\", new ShootCommand(shooter)); These can be triggered at waypoints in paths. SendableChooser Integration In RobotContainer, create a chooser: private final SendableChooser<Command> autoChooser = new SendableChooser<>(); autoChooser.setDefaultOption(\"Do Nothing\", Commands.none()); autoChooser.addOption(\"Simple Auto\", Autos.simpleAuto(swerve)); autoChooser.addOption(\"4 Note Auto\", Autos.fourNoteAuto(swerve, intake, shooter)); SmartDashboard.putData(\"Auto Chooser\", autoChooser); Testing Autos Use simulation to verify paths Test odometry reset at start Verify end positions match expectations Practice mode for timing validation Log trajectory following errors","title":"Autos.java"},{"location":"I%27m%20New%20Here/Codebase%20Overview/commandbasedprogramming/","text":"Command Based Programming What is Command Based Programming? Command Based Programming is the official WPILib framework for organizing robot code. It structures your code around two main concepts: - Subsystems : Represent robot mechanisms (drivetrain, arm, intake) - Commands : Represent actions the robot can perform Why Use Command Based? Benefits of the framework: - Clear separation of mechanism control (subsystems) and behavior (commands) - Automatic handling of resource conflicts (one command per subsystem) - Built-in support for sequential and parallel command groups - Easier testing and debugging - Standard structure across FRC teams - Integration with FRC tools (PathPlanner, Choreo, etc.) Core Concepts Subsystems : - Own hardware components (motors, sensors) - Define low-level operations - Have default commands that run when no other command is using them - Example: DrivetrainSubsystem, IntakeSubsystem Commands : - Define high-level robot behaviors - Require specific subsystems - Have lifecycle methods (initialize, execute, end, isFinished) - Can be bound to buttons or triggers - Example: DriveWithJoystick, ShootGamePiece Command Lifecycle Commands follow this lifecycle: 1. initialize() : Called once when command starts 2. execute() : Called repeatedly while command runs (50Hz) 3. isFinished() : Returns true when command should end 4. end(interrupted) : Called once when command ends CommandScheduler The CommandScheduler: - Runs during robot periodic methods - Manages which commands are active - Handles subsystem requirements - Cancels conflicting commands automatically","title":"Command Based Programming"},{"location":"I%27m%20New%20Here/Codebase%20Overview/commandstructure/","text":"Breaking Down Commands Command Structure A typical command class has this structure: public class ExampleCommand extends CommandBase { private final ExampleSubsystem subsystem; public ExampleCommand(ExampleSubsystem subsystem) { this.subsystem = subsystem; addRequirements(subsystem); // Claim the subsystem } @Override public void initialize() { // Setup code } @Override public void execute() { // Repeated action code } @Override public void end(boolean interrupted) { // Cleanup code } @Override public boolean isFinished() { // Return true when command should stop return false; } } Command Types Instant Commands : - Complete immediately (one-time actions) - Example: Toggling a solenoid Run Commands : - Execute continuously until interrupted - Example: Driving with joysticks Timed Commands : - Run for a specific duration - Example: Run intake for 2 seconds Sequential/Parallel Command Groups : - Combine multiple commands - Example: Drive forward, then turn, then shoot Key Methods Explained initialize() : - Set initial states - Reset variables - Start timers execute() : - Called 50 times per second - Implement main command logic - Update subsystem outputs isFinished() : - Return true to end command - Check sensors, timers, or conditions - Always returns false for infinite commands end(interrupted) : - Stop motors - Reset states - Handle both normal and interrupted endings","title":"Breaking Down Commands"},{"location":"I%27m%20New%20Here/Codebase%20Overview/constantsjava/","text":"Constants.java What is Constants.java? Constants.java is a central file that stores all robot configuration values in one place. This includes: - CAN IDs for motors and sensors - Physical measurements (wheel diameter, track width) - PID gains - Speed limits - Game-specific values Why Use Constants.java? Benefits of centralizing constants: - Easy to find and modify : All values in one file - Prevents magic numbers : Named constants explain meaning - Reduces errors : Change once, affects everywhere - Type safety : Compile-time checking - Version control : Track configuration changes Typical Structure public final class Constants { // Prevent instantiation private Constants() {} public static final class DriveConstants { public static final int FRONT_LEFT_DRIVE_ID = 1; public static final int FRONT_LEFT_TURN_ID = 2; public static final double WHEEL_DIAMETER_METERS = 0.1016; public static final double TRACK_WIDTH_METERS = 0.635; public static final double MAX_SPEED_MPS = 4.5; public static final double MAX_ANGULAR_SPEED = 2 * Math.PI; } public static final class IntakeConstants { public static final int MOTOR_ID = 10; public static final double INTAKE_SPEED = 0.75; } public static final class OIConstants { public static final int DRIVER_CONTROLLER_PORT = 0; public static final int OPERATOR_CONTROLLER_PORT = 1; public static final double DEADBAND = 0.1; } } Naming Conventions Follow these conventions: - Class name: Constants (plural) - Use UPPER_SNAKE_CASE for constant names - Group related constants in nested classes - Use descriptive names that explain purpose - Include units in names when applicable (SPEED_MPS, DISTANCE_METERS) Accessing Constants motor.set(Constants.IntakeConstants.INTAKE_SPEED); double maxSpeed = Constants.DriveConstants.MAX_SPEED_MPS;","title":"Constants.java"},{"location":"I%27m%20New%20Here/Codebase%20Overview/deployjava/","text":"/deploy Directory What is the /deploy Directory? The deploy directory (full path: src/main/deploy/ ) contains non-code resources that are deployed to the robot alongside your Java code. These files are accessible at runtime on the SystemCore/RoboRIO. Common Files in /deploy Choreo Trajectories ( choreo/ subdirectory): - .traj files containing path waypoints - Generated by Choreo trajectory planner - Loaded at runtime using Choreo.getTrajectory(name) PathPlanner Paths ( pathplanner/ subdirectory): - .path files for autonomous routines - Created in PathPlanner GUI - Include waypoints, constraints, event markers Limelight Pipelines : - JSON files with vision pipeline configurations - Backup/restore Limelight settings - Version control camera configurations Custom Configuration Files : - JSON, YAML, CSV files for robot settings - Field layouts - Custom data files Accessing Deploy Files Deploy files are available at runtime: // Choreo trajectory ChoreoTrajectory traj = Choreo.getTrajectory(\"MyPath\"); // PathPlanner path PathPlannerPath path = PathPlannerPath.fromPathFile(\"MyPath\"); // Custom file using Filesystem String path = Filesystem.getDeployDirectory() + \"/myconfig.json\"; File configFile = new File(path); Deployment Process When you deploy code: 1. Robot code is compiled to JAR file 2. Deploy directory contents are copied to robot 3. Files are placed in /home/lvuser/deploy/ on SystemCore/RoboRIO 4. Old files are replaced with new versions Best Practices Keep deploy files small (SystemCore/RoboRIO has limited storage) Use version control for all deploy files Organize files in subdirectories Document what each file is for Remove unused files Test file loading early in development File Size Considerations Trajectories: Usually < 100 KB each Images: Avoid large images, use compressed formats Total deploy folder: Keep under 10 MB when possible Large files slow down deployment","title":"/deploy"},{"location":"I%27m%20New%20Here/Codebase%20Overview/generatedjava/","text":"/generated Directory What is the /generated Directory? The generated directory (full path: src/main/java/frc/robot/generated/ ) contains auto-generated Java code created by external tools. This code should NOT be manually edited. Common Generated Files TunerConstants.java (from Phoenix Tuner X): - Generated by CTRE Phoenix Tuner X - Contains swerve module configurations - Includes CAN IDs, gear ratios, PID gains - Created using the Swerve Project Generator Choreo-generated trajectory classes : - Java classes for each trajectory - Contain trajectory waypoints and timing - Generated when exporting from Choreo Why Auto-Generated Code? Benefits of generated code: - Consistency : Tool ensures correct format - Reduced errors : No manual typing mistakes - Easy updates : Regenerate when configuration changes - Type safety : Proper Java classes with compile-time checking - Version control : Track configuration changes Working with Generated Code DO : - Import generated classes in your code - Use constants and methods from generated code - Regenerate when hardware configuration changes - Commit generated code to version control DON'T : - Manually edit generated files - Copy generated code elsewhere - Assume generated code is always up-to-date Regenerating Code When hardware changes: 1. Update configuration in the tool (Phoenix Tuner X, Choreo) 2. Regenerate the code 3. Review changes in version control 4. Test with new configuration 5. Commit updated generated files Example Usage Using TunerConstants in your code: import frc.robot.generated.TunerConstants; public class SwerveSubsystem extends SubsystemBase { public SwerveSubsystem() { // Use generated constants SwerveDrivetrain drivetrain = TunerConstants.DriveTrain; } }","title":"/generated"},{"location":"I%27m%20New%20Here/Codebase%20Overview/limelighthelpersjava/","text":"LimelightHelpers.java What is LimelightHelpers? LimelightHelpers.java is a utility class provided by Limelight that simplifies communication with Limelight cameras. It provides easy-to-use methods for: - Getting target information - Retrieving pose estimates - Configuring pipeline settings - Accessing neural network results - Controlling LEDs Common Methods Target Information : // Check if camera sees a valid target boolean hasTarget = LimelightHelpers.getTV(limelightName); // Get horizontal angle to target (degrees) double tx = LimelightHelpers.getTX(limelightName); // Get vertical angle to target (degrees) double ty = LimelightHelpers.getTY(limelightName); // Get target area (0-100% of image) double ta = LimelightHelpers.getTA(limelightName); Pose Estimation : // Get robot pose from AprilTags (MegaTag2) PoseEstimate poseEstimate = LimelightHelpers.getBotPoseEstimate_wpiBlue(limelightName); // Access pose data Pose2d robotPose = poseEstimate.pose; double latency = poseEstimate.timestampSeconds; LED Control : // Set LED mode LimelightHelpers.setLEDMode_ForceOn(limelightName); LimelightHelpers.setLEDMode_ForceOff(limelightName); LimelightHelpers.setLEDMode_ForceBlink(limelightName); Pipeline Control : // Switch to specific pipeline LimelightHelpers.setPipelineIndex(limelightName, 0); // Get current pipeline long currentPipeline = LimelightHelpers.getCurrentPipelineIndex(limelightName); Using LimelightHelpers Typical usage in subsystem: public class VisionSubsystem extends SubsystemBase { private static final String LIMELIGHT_NAME = \"limelight\"; public Optional<Pose2d> getRobotPose() { PoseEstimate estimate = LimelightHelpers.getBotPoseEstimate_wpiBlue(LIMELIGHT_NAME); if (estimate.tagCount >= 2) { // Require at least 2 tags return Optional.of(estimate.pose); } return Optional.empty(); } public boolean hasTarget() { return LimelightHelpers.getTV(LIMELIGHT_NAME); } } Best Practices Use descriptive Limelight names if you have multiple Check for valid targets before using data Consider latency when using pose estimates Use appropriate pipelines for different tasks Don't call Limelight methods too frequently (NetworkTables overhead)","title":"LimelightHelpers.java"},{"location":"I%27m%20New%20Here/Codebase%20Overview/robotcontainerjava/","text":"RobotContainer.java What is RobotContainer? RobotContainer is where the bulk of your robot's structure is defined. It: - Creates all subsystems - Creates controllers and buttons - Binds commands to buttons - Defines autonomous routines - Configures default commands This keeps Robot.java clean and organizes robot configuration in one place. Typical Structure public class RobotContainer { // Subsystems private final SwerveSubsystem swerveSubsystem; private final IntakeSubsystem intakeSubsystem; private final ShooterSubsystem shooterSubsystem; // Controllers private final CommandXboxController driverController; private final CommandXboxController operatorController; // Constructor public RobotContainer() { // Create subsystems swerveSubsystem = new SwerveSubsystem(); intakeSubsystem = new IntakeSubsystem(); shooterSubsystem = new ShooterSubsystem(); // Create controllers driverController = new CommandXboxController(Constants.DRIVER_PORT); operatorController = new CommandXboxController(Constants.OPERATOR_PORT); // Configure button bindings configureButtonBindings(); // Set default commands configureDefaultCommands(); } public Command getAutonomousCommand() { return autoChooser.getSelected(); } } Key Methods configureButtonBindings() : - Binds commands to controller buttons - Uses CommandXboxController for trigger-based binding private void configureButtonBindings() { driverController.a().onTrue(new IntakeCommand(intakeSubsystem)); driverController.b().onTrue(new ShootCommand(shooterSubsystem)); operatorController.rightBumper().whileTrue(new OuttakeCommand(intakeSubsystem)); } configureDefaultCommands() : - Sets commands that run when subsystem is not being used private void configureDefaultCommands() { swerveSubsystem.setDefaultCommand( new SwerveJoystickCommand( swerveSubsystem, () -> -driverController.getLeftY(), () -> -driverController.getLeftX(), () -> -driverController.getRightX(), () -> true // Field-centric ) ); } getAutonomousCommand() : - Returns the selected autonomous command - Often uses SendableChooser for dashboard selection Organization Tips Group related subsystem creation Use descriptive variable names Comment complex button binding logic Consider splitting very large RobotContainer into multiple classes","title":"RobotContainer.java"},{"location":"I%27m%20New%20Here/Codebase%20Overview/robotjava/","text":"Robot.java What is Robot.java? Robot.java is the main entry point of your robot code. It extends TimedRobot and contains methods that are called automatically at different stages of robot operation. Robot Lifecycle Methods robotInit() : - Called once when robot code starts - Typically creates RobotContainer - Initializes any global systems @Override public void robotInit() { robotContainer = new RobotContainer(); } robotPeriodic() : - Called every 20ms (50Hz) regardless of mode - Runs CommandScheduler - Updates dashboards @Override public void robotPeriodic() { CommandScheduler.getInstance().run(); } Mode-Specific Methods Disabled Mode : @Override public void disabledInit() { // Called when robot is disabled } @Override public void disabledPeriodic() { // Called periodically while disabled } Autonomous Mode : @Override public void autonomousInit() { // Get and schedule autonomous command autonomousCommand = robotContainer.getAutonomousCommand(); if (autonomousCommand != null) { autonomousCommand.schedule(); } } @Override public void autonomousPeriodic() { // No code needed - CommandScheduler handles it } Teleop Mode : @Override public void teleopInit() { // Cancel autonomous command when teleop starts if (autonomousCommand != null) { autonomousCommand.cancel(); } } @Override public void teleopPeriodic() { // No code needed - CommandScheduler handles it } Test Mode : @Override public void testInit() { CommandScheduler.getInstance().cancelAll(); } @Override public void testPeriodic() { // Used for testing specific subsystems } Best Practices Keep Robot.java minimal - put logic in RobotContainer Always run CommandScheduler in robotPeriodic() Don't create subsystems in Robot.java Use mode init methods for mode-specific setup","title":"Robot.java"},{"location":"I%27m%20New%20Here/Codebase%20Overview/subsystemstructure/","text":"Breaking Down Subsystems Subsystem Structure A typical subsystem class structure: public class ExampleSubsystem extends SubsystemBase { // Hardware components private final CANSparkMax motor; private final Encoder encoder; // Constructor - initialize hardware public ExampleSubsystem() { motor = new CANSparkMax(Constants.MOTOR_ID, MotorType.kBrushless); encoder = motor.getEncoder(); // Configure hardware motor.setIdleMode(IdleMode.kBrake); motor.setSmartCurrentLimit(40); } // Methods to control the subsystem public void setSpeed(double speed) { motor.set(speed); } public double getPosition() { return encoder.getPosition(); } // Periodic runs 50 times per second @Override public void periodic() { // Update telemetry, safety checks, etc. SmartDashboard.putNumber(\"Motor Speed\", motor.get()); } } Subsystem Responsibilities Subsystems should: - Own hardware : Create and configure motor controllers, sensors - Provide control methods : Simple, reusable operations - Handle safety : Limit checks, fault detection - Publish telemetry : Send data to dashboard - Maintain state : Track mechanism position/status Important Methods Constructor : - Initialize hardware objects - Configure device settings - Set default values periodic() : - Called automatically 50 times per second - Update telemetry - Safety monitoring - State machine updates Control Methods : - Simple operations (setSpeed, getPosition) - Keep logic in commands when possible - Return useful information Default Commands Subsystems can have a default command that runs when no other command requires them: setDefaultCommand(new DefaultDriveCommand(this)); Common default commands: - Drivetrain: Joystick control - Arm: Hold position - Intake: Do nothing (motors off)","title":"Breaking Down Subsystems"},{"location":"I%27m%20New%20Here/Codebase%20Overview/swervejava/","text":"SwerveSubsystem.java What is SwerveSubsystem? SwerveSubsystem is the main subsystem that controls the swerve drive system. It manages: - Four swerve modules (one per wheel) - Odometry (tracking robot position on field) - Gyroscope for heading - Field-centric drive control - Integration with PathPlanner/Choreo for autonomous Key Components The SwerveSubsystem typically includes: public class SwerveSubsystem extends SubsystemBase { // Swerve modules private final SwerveModule frontLeft; private final SwerveModule frontRight; private final SwerveModule rearLeft; private final SwerveModule rearRight; // Gyroscope for robot heading private final Gyro gyro; // Odometry for position tracking private final SwerveDriveOdometry odometry; // Kinematics for coordinate conversions private final SwerveDriveKinematics kinematics; } Core Methods drive() : - Takes desired velocities (vx, vy, omega) - Converts to module states using kinematics - Commands each module to desired state periodic() : - Updates odometry with current module states - Publishes telemetry (position, heading, speeds) - Safety monitoring resetOdometry() : - Sets robot's known position on field - Called at start of autonomous getPosition() : - Returns current robot pose (x, y, rotation) - Used by PathPlanner and pose estimation Swerve Drive Modes Robot-Centric : - Forward is always robot's forward direction - Simpler for beginners Field-Centric : - Forward is always away from driver - Uses gyro to adjust for robot rotation - Preferred for competition driving Integration with Autonomous The SwerveSubsystem integrates with path following: - Implements methods for PathPlanner - Provides current pose to trajectory following - Executes commanded velocities from path - Uses vision (Limelight) for pose correction","title":"SwerveSubsystem.java"},{"location":"I%27m%20New%20Here/Codebase%20Overview/swervejoystickcommandjava/","text":"SwerveJoystickCommand.java What is SwerveJoystickCommand? SwerveJoystickCommand is typically the default command for the SwerveSubsystem. It: - Reads input from driver's controller - Applies deadband and scaling to joystick inputs - Converts joystick values to robot velocities - Enables field-centric or robot-centric drive - Handles drive speed limiting Command Structure public class SwerveJoystickCommand extends CommandBase { private final SwerveSubsystem swerveSubsystem; private final Supplier<Double> xSpeedSupplier; private final Supplier<Double> ySpeedSupplier; private final Supplier<Double> rotSpeedSupplier; private final Supplier<Boolean> fieldCentricSupplier; public SwerveJoystickCommand( SwerveSubsystem swerveSubsystem, Supplier<Double> xSpeed, Supplier<Double> ySpeed, Supplier<Double> rotSpeed, Supplier<Boolean> fieldCentric) { this.swerveSubsystem = swerveSubsystem; this.xSpeedSupplier = xSpeed; this.ySpeedSupplier = ySpeed; this.rotSpeedSupplier = rotSpeed; this.fieldCentricSupplier = fieldCentric; addRequirements(swerveSubsystem); } } Execute Method The execute() method: 1. Gets current joystick values from suppliers 2. Applies deadband to eliminate drift 3. Applies scaling curves for better control 4. Converts to field-centric if enabled 5. Passes velocities to swerve subsystem Input Processing Deadband : - Ignores small joystick movements - Prevents unintended robot movement - Typical value: 0.05 to 0.1 Scaling : - Square or cube inputs for finer control at low speeds - Maintains sign (positive/negative direction) - scaled = Math.copySign(value * value, value) Speed Limiting : - Multiply by max speed constants - Allow slow mode for precise positioning - Example: 50% speed for cargo alignment Why Use Suppliers? Suppliers (functional interfaces) allow: - Late binding of joystick values - Command reusability - Easier testing and simulation - Flexibility in input sources","title":"SwerveJoystickCommand.java"},{"location":"I%27m%20New%20Here/Git%20Overview/basicgitconcepts/","text":"What is Git/GitHub? Understanding Git Git is a distributed version control system that tracks changes to your code over time. It allows multiple people to work on the same project simultaneously, maintains a complete history of changes, and helps prevent code loss. Understanding GitHub GitHub is a web-based platform that hosts Git repositories. It provides: - Cloud storage for your code - Collaboration tools (pull requests, issues, discussions) - Code review features - Project management capabilities - Team access control - Integration with development tools Why Use Git/GitHub in FRC? Git and GitHub are essential for FRC teams because they: - Protect your code from accidental loss - Enable collaboration among programming team members - Maintain a history of all code changes - Allow reverting to previous working versions - Facilitate code reviews and quality control - Store documentation alongside code","title":"What is Git/GitHub?"},{"location":"I%27m%20New%20Here/Git%20Overview/cloningrepository/","text":"Cloning a Repository What is Cloning? Cloning creates a local copy of a remote repository on your computer. This gives you: - All project files - Complete commit history - All branches - Connection to the remote repository How to Clone a Repository Using VS Code: 1. Open VS Code 2. Press Ctrl+Shift+P (Cmd+Shift+P on Mac) 3. Type \"Git: Clone\" and select it 4. Paste the repository URL from GitHub 5. Choose a folder to save the repository 6. Open the cloned repository Using Command Line: git clone https://github.com/YourTeam/YourRepo.git cd YourRepo After Cloning Once cloned: - Build the project to verify everything works - Install any necessary vendor dependencies - Create a new branch for your work - Never commit directly to main branch - Always pull latest changes before starting new work","title":"Cloning a Repository"},{"location":"I%27m%20New%20Here/Git%20Overview/creatingrepository/","text":"Creating a Repository When to Create a Repository Create a new repository when: - Starting a new robot project - Beginning a new season - Creating a standalone tool or utility - Starting documentation or training materials Creating a Repository on GitHub Steps to create a repository: 1. Go to GitHub.com and sign in 2. Click the \"+\" icon, then \"New repository\" 3. Choose a descriptive name (e.g., \"2024-RobotCode\") 4. Add a description of the project 5. Choose public or private visibility 6. Initialize with a README 7. Add a .gitignore file (select Java/WPILib template) 8. Choose a license (optional, often MIT for FRC) 9. Click \"Create repository\" Best Practices When creating repositories: - Use clear, descriptive names - Include a comprehensive README - Set up appropriate .gitignore files - Consider repository templates for consistency - Establish branch protection rules for main branch","title":"Creating a Repository"},{"location":"I%27m%20New%20Here/Git%20Overview/downloadingcode/","text":"Downloading Code Downloading vs Cloning There are two ways to get code from GitHub: - Downloading : Gets just the files (no Git history) - Cloning : Gets files AND complete version control For FRC development, always clone rather than download so you can: - Commit your changes - Push to GitHub - Pull updates from teammates - Use branches effectively When to Download Instead of Clone Only download (not clone) when: - You want to view code without contributing - Getting example code to reference - Downloading release packages - Getting files for a completely different project Downloading from GitHub If you must download: 1. Navigate to the repository on GitHub 2. Click the green \"Code\" button 3. Select \"Download ZIP\" 4. Extract the ZIP file 5. Note: Downloaded code is NOT a Git repository Converting a Download to a Repository If you downloaded code but need Git features: 1. Create a new repository on GitHub 2. Initialize Git in the downloaded folder: git init 3. Add the remote: git remote add origin <URL> 4. Stage and commit all files 5. Push to GitHub","title":"Downloading Code"},{"location":"I%27m%20New%20Here/Git%20Overview/githubissues/","text":"Staying Organized with GitHub Issues What are GitHub Issues? GitHub Issues are a project management tool built into GitHub. They help teams track: - Bugs that need fixing - Features to implement - Questions about the code - Documentation improvements - Task assignments Creating Effective Issues A good issue includes: - Clear, descriptive title - Detailed description of the problem or feature - Steps to reproduce (for bugs) - Expected vs actual behavior - Labels for categorization (bug, enhancement, documentation) - Assignment to a team member - Milestone association (optional) - References to related issues or PRs Using Issues for Team Organization Issues help teams by: - Creating a central task list - Preventing duplicate work - Tracking progress on features - Documenting decisions and discussions - Linking code changes to specific tasks - Planning sprints and milestones - Keeping history of problems and solutions Issue Workflow Typical issue lifecycle: 1. Create issue describing task/bug 2. Assign to a team member 3. Team member creates branch for the work 4. Work is done and PR is created 5. PR references the issue (e.g., \"Fixes #42\") 6. PR is reviewed and merged 7. Issue automatically closes when PR merges","title":"Staying Organized with GitHub Issues"},{"location":"I%27m%20New%20Here/Git%20Overview/mergingcode/","text":"Resolving Merge Conflicts What is a Merge Conflict? A merge conflict occurs when Git cannot automatically combine changes from different branches because the same lines of code were modified differently. This commonly happens when: - Multiple people edit the same file - Changes are made to a file while it's being edited elsewhere - A branch hasn't been updated before merging Identifying Merge Conflicts Git marks conflicts in the file with special markers: <<<<<<< HEAD Your changes ======= Incoming changes from other branch >>>>>>> branch-name The section between <<<<<<< HEAD and ======= is your version. The section between ======= and >>>>>>> branch-name is the incoming version. Resolving Conflicts To resolve a merge conflict: 1. Open the conflicted file in VS Code 2. Review both versions of the code 3. Decide which changes to keep (or combine both) 4. Remove the conflict markers ( <<<<<<< , ======= , >>>>>>> ) 5. Test that the code works correctly 6. Stage the resolved file 7. Complete the merge with a commit Preventing Conflicts Reduce conflicts by: - Pulling latest changes before starting work - Making small, focused commits - Communicating with teammates about what you're working on - Working on different files when possible - Merging frequently to keep branches up to date","title":"Resolving Merge Conflicts"},{"location":"I%27m%20New%20Here/Git%20Overview/pullscommitspushes/","text":"Pulls, Pushes, and Commits What is a Commit? A commit is a snapshot of your code at a specific point in time. It records: - What files were changed - What the changes were - Who made the changes - When the changes were made - A message describing why the changes were made What is a Push? Pushing uploads your local commits to the remote repository (GitHub). This: - Backs up your code to the cloud - Makes your changes visible to teammates - Updates the team's shared codebase - Enables others to pull your changes What is a Pull? Pulling downloads commits from the remote repository to your local machine. This: - Gets the latest code changes from teammates - Syncs your local repository with the team's work - Prepares your workspace for new changes - Should be done before starting new work","title":"Pulls, Pushes, and Commits"},{"location":"I%27m%20New%20Here/Git%20Overview/reposbranchesprs/","text":"Repositories, Branches, and Pull Requests What is a Repository? A repository (or \"repo\") is a folder that contains all of your project files and the complete version history. Each FRC project typically has its own repository. Repositories contain: - All code files - Documentation - Configuration files - Complete commit history - Branch information What is a Branch? A branch is an independent line of development within a repository. Branches allow you to: - Work on features without affecting the main code - Experiment safely - Isolate bug fixes - Collaborate without conflicts Common branch names: - main or master : The primary stable branch - dev or development : Ongoing development branch - Feature branches: feature/new-intake , fix/auto-bug What is a Pull Request (PR)? A Pull Request is a proposal to merge changes from one branch into another. PRs enable: - Code review before merging - Discussion about changes - Automated testing - Team approval workflow - Documentation of why changes were made","title":"Repos, Branches, and PRs"},{"location":"I%27m%20New%20Here/Git%20Overview/stagingvscommiting/","text":"Staging vs Committing What is Staging? Staging (also called \"adding\") is the process of selecting which changes you want to include in your next commit. Think of it as preparing a package before shipping it. The staging area allows you to: - Review changes before committing - Group related changes together - Exclude temporary or unfinished work - Create clean, focused commits What is Committing? Committing takes all staged changes and creates a permanent snapshot in your repository's history. Each commit should: - Have a clear, descriptive message - Contain related changes (one logical change per commit) - Be complete and functional (doesn't break the build) - Follow your team's commit message conventions The Workflow The typical workflow is: 1. Make changes to files 2. Review what you changed 3. Stage the files you want to commit (git add) 4. Commit the staged changes with a message (git commit) 5. Push commits to GitHub (git push)","title":"Staging vs Commiting"},{"location":"I%27m%20New%20Here/Hardware%20Overview/basicconcepts/","text":"Basic Hardware Concepts What is FRC Hardware? FRC (FIRST Robotics Competition) hardware consists of all the physical electrical and mechanical components that make up a robot. Understanding these basic concepts is essential for building, maintaining, and troubleshooting your robot. Core Hardware Components The core hardware system includes: - Control system (SystemCore/RoboRIO) - Power distribution - Motor controllers - Motors - Sensors - Pneumatics (if used) Electrical Safety Always follow proper electrical safety procedures: - Disconnect battery before working on electrical systems - Check for proper wire gauges - Ensure all connections are secure - Use proper crimping tools for connectors","title":"Basic Concepts"},{"location":"I%27m%20New%20Here/Hardware%20Overview/breaker/","text":"Circuit Breaker Overview What is a Circuit Breaker? A circuit breaker is a safety device that automatically interrupts electrical flow when the current exceeds a safe level. In FRC robots, circuit breakers protect components from damage due to electrical overload. Types of Breakers in FRC FRC robots use several types of breakers: - Main breaker (120A): Protects the entire robot - Branch breakers (various amperage ratings): Protect individual circuits - Snap Action breakers: Manual reset breakers for specific components When Breakers Trip If a breaker trips, it indicates an overcurrent condition. Common causes: - Motor stall - Short circuit - Too many high-current devices on one circuit - Damaged wiring","title":"Breaker"},{"location":"I%27m%20New%20Here/Hardware%20Overview/cancoders/","text":"CANCoders Overview What is a CANCoder? A CANCoder is a magnetic absolute encoder made by CTRE (Cross The Road Electronics). It provides precise position and velocity measurements over the CAN bus, making it ideal for mechanisms that need to know their exact position. Key Features CANCoders provide: - Absolute position (maintains position through power cycles) - 4096 counts per revolution resolution - CAN bus communication - Magnetic sensing (no physical contact) - Velocity measurement - Configurable units and offsets Common Applications CANCoders are used for: - Swerve module steering position (absolute angle) - Arm and elevator position tracking - Turret angle measurement - Any mechanism requiring absolute position feedback - Determining mechanism positions during autonomous init","title":"CANCoders"},{"location":"I%27m%20New%20Here/Hardware%20Overview/coral/","text":"Google Coral USB Accelerator Overview What is the Google Coral? The Google Coral USB Accelerator is an AI hardware accelerator that plugs into the Limelight 3. It enables real-time neural network inference for custom object detection tasks like identifying game pieces. How it Works The Coral accelerator: - Contains an Edge TPU (Tensor Processing Unit) - Processes neural networks trained with TensorFlow - Connects via USB to the Limelight 3 - Runs inference much faster than CPU-only processing - Enables real-time object detection at high frame rates FRC Applications Common uses in FRC: - Detecting game pieces (cones, cubes, notes, etc.) - Classifying game piece types or colors - Custom target detection not possible with traditional vision - Running complex vision pipelines in parallel - Improving detection accuracy over retroreflective vision","title":"Google Coral USB Accelerator"},{"location":"I%27m%20New%20Here/Hardware%20Overview/limelight/","text":"Limelight 3 Smart Camera Overview What is the Limelight 3? The Limelight 3 is a smart camera designed for FRC robotics. It performs real-time vision processing onboard, providing pose estimation, target detection, and AprilTag tracking with minimal latency. Limelight 3 Features Key features: - Dual cameras (wide FOV and narrow FOV) - Onboard vision processing (no RoboRIO load) - AprilTag detection and pose estimation - MegaTag2 for multi-tag odometry - Neural network support via Google Coral - Ethernet connection for low-latency data - Web-based configuration interface Vision Processing Capabilities The Limelight 3 can: - Detect and track AprilTags - Provide robot pose estimation - Run custom neural networks - Detect game pieces using color/shape - Stream video to driver station - Log vision data for analysis","title":"Limelight 3"},{"location":"I%27m%20New%20Here/Hardware%20Overview/navx/","text":"Studica NavX3-CAN Overview What is the NavX3-CAN? The Studica NavX3-CAN is an inertial measurement unit (IMU) that provides precise orientation data to your robot. It connects via CAN bus and provides yaw, pitch, roll, and acceleration data. Key Features The NavX3-CAN provides: - 3-axis gyroscope for rotation tracking - 3-axis accelerometer for linear motion - Magnetometer for compass heading - Quaternion-based orientation calculations - CAN bus communication Common Applications The NavX3-CAN is used for: - Field-centric swerve drive control - Auto-balancing on charging stations - Precise autonomous turning - Detecting tipping or collision - Dead reckoning navigation","title":"Studica NavX3-CAN"},{"location":"I%27m%20New%20Here/Hardware%20Overview/neo/","text":"REV NEO Brushless Motors V1.1 Overview What is the NEO Motor? The REV NEO is a brushless DC motor designed specifically for FRC robotics. It provides high power output in a compact package and integrates seamlessly with SPARK MAX motor controllers. NEO Specifications Key specifications: - Free speed: 5,676 RPM - Stall torque: 2.6 N\u22c5m (23 lb\u22c5in) - Stall current: 105A - Free current: 1.8A - Brushless design for longer lifespan - Built-in hall effect sensors Common Uses NEO motors are commonly used for: - Swerve drive modules (drive and steering) - Shooter wheels - Intake mechanisms - Elevator systems - Any application requiring efficient, powerful motors","title":"REV NEO Brushless Motors V1.1"},{"location":"I%27m%20New%20Here/Hardware%20Overview/pdh/","text":"REV Power Distribution Hub (PDH) Overview What is the PDH? The REV Power Distribution Hub (PDH) is the central power distribution system for FRC robots. It takes power from the battery and distributes it to all electrical components while providing current monitoring and circuit protection. PDH Features The PDH provides: - 20 switchable high-current channels (40A each) - 3 low-current channels (15A each) with smaller connectors - Individual current monitoring for each channel - CAN bus communication for telemetry - Total current and voltage monitoring - Built-in circuit breakers Monitoring and Safety The PDH enables: - Real-time current draw monitoring for all channels - Identifying power-hungry mechanisms - Detecting electrical issues before they cause failures - Logging power consumption data - Automated current limiting in code","title":"REV PDH"},{"location":"I%27m%20New%20Here/Hardware%20Overview/robotradio/","text":"Robot Radio Overview What is the Robot Radio? The robot radio is a specialized wireless networking device that provides communication between the driver station and the robot. It must be properly configured with your team number and operated on the correct frequency. Radio Configuration The radio must be: - Programmed with your team number - Updated to the current firmware - Configured for FRC field use (5GHz band) - Properly powered (POE or barrel jack) - Mounted securely on the robot Communication and Networking The radio provides: - Wireless link to driver station - Network connectivity for robot controller - Compatible with FRC field management system - IP addressing based on team number - Proper bandwidth for robot control and camera feeds","title":"Robot Radio"},{"location":"I%27m%20New%20Here/Hardware%20Overview/rsl/","text":"Robot Signal Light (RSL) Overview What is the RSL? The Robot Signal Light (RSL) is a required indicator light that displays the current state of your robot. It must be mounted on the robot and clearly visible to referees and drive team members. RSL States and Meanings The RSL displays different patterns to indicate robot state: - Solid ON: Robot is enabled and receiving communication - Blinking: Robot is disabled but receiving communication - OFF: Robot is not receiving communication from the driver station FRC Requirements The RSL must: - Be the approved FRC RSL model - Be clearly visible from multiple angles - Be properly connected to the SystemCore/RoboRIO RSL port - Flash at the correct rate when disabled","title":"RSL"},{"location":"I%27m%20New%20Here/Hardware%20Overview/sparkmax/","text":"SPARK MAX Motor Controllers Overview What is the SPARK MAX? The SPARK MAX is a brushless motor controller made by REV Robotics. It's designed to control NEO brushless motors and provides advanced features like PID control, motion profiling, and telemetry over CAN bus. Key Features The SPARK MAX provides: - Brushless motor control for NEO and NEO 550 motors - CAN bus and PWM control modes - Onboard PID control - Smart Motion for motion profiling - Current limiting and monitoring - USB and CAN configuration via REV Hardware Client - Data port for external encoders Configuration and Usage To use a SPARK MAX: - Connect to motor via integrated motor wires - Set CAN ID using REV Hardware Client - Update firmware to latest version - Configure motor type (NEO/NEO 550) - Set current limits appropriate for your mechanism - Configure PID gains for closed-loop control - Set idle mode (brake or coast)","title":"SparkMAX Motor Controllers"},{"location":"I%27m%20New%20Here/Hardware%20Overview/swerve/","text":"Swerve Modules/Drive Overview What is Swerve Drive? Swerve drive is an advanced drivetrain system where each wheel can independently rotate and steer. This provides omnidirectional movement, allowing the robot to drive in any direction while rotating independently. Swerve Module Components Each swerve module consists of: - Drive motor (NEO) - propels the wheel - Steering motor (NEO) - rotates the module - CANCoder - measures absolute steering angle - Bevel gears for steering - Module frame and mounting hardware Advantages of Swerve Drive Swerve drive provides: - Omnidirectional movement (strafe in any direction) - Independent rotation while driving - Field-centric control for easier driving - Superior maneuverability - Efficient path following for autonomous","title":"Swerve Modules/Drive"},{"location":"I%27m%20New%20Here/Hardware%20Overview/systemcore/","text":"SystemCore Overview SystemCore will replace the NI RoboRIO as the FRC-legal control system in 2027. Documentation will be added in coming years.","title":"SystemCore"},{"location":"I%27m%20New%20Here/Hardware%20Overview/vrm/","text":"Voltage Regulator Module (VRM) Overview What is the VRM? The Voltage Regulator Module (VRM) is a device that converts the 12V battery power to regulated 12V and 5V outputs. These regulated voltages power accessories like cameras, LED strips, and other devices that require stable voltage. VRM Specifications The VRM provides: - Two 12V/2A regulated outputs - Two 5V/2A regulated outputs - Overcurrent protection - Reverse polarity protection Common Uses The VRM is typically used to power: - Limelight and other vision cameras - LED strips for signaling - Custom circuits requiring regulated voltage - Sensors that need stable 5V power","title":"VRM"},{"location":"I%27m%20New%20Here/Java%20Overview/anatomyofclasses/","text":"Anatomy of Classes What is a Class? A class is a blueprint for creating objects. It defines: - Fields (variables): Data the class stores - Methods (functions): Behaviors the class can perform - Constructors : Special methods for creating instances Class Structure Basic class anatomy: public class Motor { // Fields (instance variables) private double speed; private int deviceID; // Constructor public Motor(int id) { this.deviceID = id; this.speed = 0.0; } // Methods public void setSpeed(double newSpeed) { this.speed = newSpeed; } public double getSpeed() { return this.speed; } } Access Modifiers Control visibility of class members: - public : Accessible from anywhere - private : Only accessible within the class - protected : Accessible within package and subclasses - default (no modifier): Accessible within package Instance vs Static Members Instance members : Belong to each object instance Static members : Belong to the class itself, shared by all instances public static final double MAX_SPEED = 1.0; // Static constant private double currentSpeed; // Instance variable","title":"Anatomy of Classes"},{"location":"I%27m%20New%20Here/Java%20Overview/assignmentoperators/","text":"Assignment Operators Basic Assignment Operator The basic assignment operator = assigns a value to a variable: int speed = 100; // Assigns 100 to speed speed = 200; // Reassigns to 200 The left side must be a variable, the right side can be any expression. Compound Assignment Operators Compound operators combine arithmetic with assignment: - += Add and assign: x += 5 is equivalent to x = x + 5 - -= Subtract and assign: x -= 3 is equivalent to x = x - 3 - *= Multiply and assign: x *= 2 is equivalent to x = x * 2 - /= Divide and assign: x /= 4 is equivalent to x = x / 4 - %= Modulus and assign: x %= 10 is equivalent to x = x % 10 Increment and Decrement Operators Shortcuts for adding or subtracting 1: - ++ Increment: counter++ is equivalent to counter = counter + 1 - -- Decrement: counter-- is equivalent to counter = counter - 1 Pre-increment vs Post-increment: int x = 5; int y = ++x; // Pre-increment: x becomes 6, y is 6 int z = x++; // Post-increment: z is 6, then x becomes 7 Practical Examples in FRC motorSpeed += 10; // Increase motor speed by 10 loopCounter++; // Increment loop counter position -= correction; // Apply correction to position","title":"Assignment Operators"},{"location":"I%27m%20New%20Here/Java%20Overview/classmembersmethods/","text":"Understanding Class Members & Methods What are Class Members? Class members are the components that make up a class: - Fields : Variables that store object state - Methods : Functions that define object behavior - Constructors : Special methods for object initialization - Nested classes : Classes defined within another class Instance vs Static Members Instance Members (non-static): - Belong to each object instance - Access with object reference: robot.getSpeed() - Each object has its own copy public class Robot { private double speed; // Instance field public void setSpeed(double s) { // Instance method speed = s; } } Static Members : - Belong to the class itself, not individual objects - Shared by all instances - Access with class name: Math.PI , Constants.MAX_SPEED public class Constants { public static final double MAX_SPEED = 1.0; // Static field public static double convertToMeters(double inches) { // Static method return inches * 0.0254; } } Method Signatures A method signature includes: - Access modifier (public, private, etc.) - Return type (void, int, double, etc.) - Method name - Parameters (if any) public double calculateDistance(double x, double y) { return Math.sqrt(x*x + y*y); } The 'this' Keyword this refers to the current object instance: public void setSpeed(double speed) { this.speed = speed; // Distinguish field from parameter }","title":"Understanding Class Members & Methods"},{"location":"I%27m%20New%20Here/Java%20Overview/comparisonoperators/","text":"Comparison Operators What are Comparison Operators? Comparison operators compare two values and return a boolean result (true or false). They are essential for making decisions in your code. Relational Operators Java provides six comparison operators: - == Equal to: x == 5 (true if x equals 5) - != Not equal to: x != 0 (true if x is not 0) - > Greater than: speed > 100 (true if speed exceeds 100) - < Less than: angle < 90 (true if angle is below 90) - >= Greater than or equal: voltage >= 12.0 - <= Less than or equal: current <= 40 Common Mistakes Avoid these pitfalls: - Using = instead of == : x = 5 assigns, x == 5 compares - Comparing objects incorrectly : Use .equals() for Strings and objects String name = \"Test\"; if (name == \"Test\") { } // Wrong for Strings if (name.equals(\"Test\")) { } // Correct Logical Operators Combine multiple comparisons: - && AND: Both conditions must be true - || OR: At least one condition must be true - ! NOT: Inverts the boolean value Examples: if (speed > 0 && speed < 100) { } // Speed between 0 and 100 if (isRed || isBlue) { } // Either red or blue if (!isDisabled) { } // Robot is enabled","title":"Comparison Operators"},{"location":"I%27m%20New%20Here/Java%20Overview/expressionsarithmetic/","text":"Expressions & Arithmetic What are Expressions? An expression is a combination of variables, operators, and values that evaluates to a single value. Expressions are fundamental building blocks in programming. Examples: 5 + 3 // Evaluates to 8 motorSpeed * 2 // Evaluates to double the motor speed x > 10 // Evaluates to true or false Arithmetic Operators Java provides standard arithmetic operators: - + Addition: 5 + 3 equals 8 - - Subtraction: 10 - 4 equals 6 - * Multiplication: 6 * 7 equals 42 - / Division: 15 / 3 equals 5 - % Modulus (remainder): 17 % 5 equals 2 Order of Operations Java follows standard mathematical order (PEMDAS): 1. Parentheses 2. Multiplication, Division, Modulus (left to right) 3. Addition, Subtraction (left to right) Examples: int result = 5 + 3 * 2; // result = 11 (not 16) int result = (5 + 3) * 2; // result = 16 Integer vs Floating-Point Division Be careful with integer division: int a = 7 / 2; // a = 3 (integer division, truncates) double b = 7.0 / 2; // b = 3.5 (floating-point division) double c = 7 / 2.0; // c = 3.5","title":"Expressions & Arithmetic"},{"location":"I%27m%20New%20Here/Java%20Overview/getters/","text":"Getters What are Getters? Getters (accessor methods) are methods that return the value of a private field. They provide controlled read access to an object's internal data. Why Use Getters? Getters promote encapsulation: - Protect internal data from direct access - Allow validation or computation before returning values - Enable changing internal implementation without affecting external code - Provide read-only access when needed Getter Syntax Standard getter pattern: public class Robot { private double speed; private boolean isEnabled; // Getter for speed public double getSpeed() { return speed; } // Getter for boolean (use 'is' prefix) public boolean isEnabled() { return isEnabled; } } Using Getters Call getters to access private fields: Robot robot = new Robot(); double currentSpeed = robot.getSpeed(); if (robot.isEnabled()) { // Do something } Naming Conventions Follow Java naming conventions: - Use get prefix: getSpeed() , getPosition() - For booleans, use is prefix: isEnabled() , isMoving() - Name should clearly indicate what is returned","title":"Getters"},{"location":"I%27m%20New%20Here/Java%20Overview/ifstatements/","text":"If, If-Else, and Else-If Statements What are Conditional Statements? Conditional statements allow your program to make decisions and execute different code based on conditions. They are fundamental to controlling program flow. If Statements Execute code only if a condition is true: if (temperature > 80) { turnOnCooling(); } If-Else Statements Execute one block if condition is true, another if false: if (batteryVoltage > 12.0) { enableRobot(); } else { disableRobot(); showWarning(); } Else-If Statements Check multiple conditions in sequence: if (distance < 10) { setSpeed(0.2); } else if (distance < 50) { setSpeed(0.5); } else if (distance < 100) { setSpeed(0.8); } else { setSpeed(1.0); } Best Practices Use clear, readable conditions Consider the order of else-if conditions (most specific first) Use braces even for single-line blocks Avoid deep nesting (consider extracting to methods) Handle all possible cases Common Patterns in FRC // Safety check if (isEnabled && !isInDangerZone()) { runMotors(); } // State-based control if (gamepad.getAButton()) { shootGamePiece(); } else if (gamepad.getBButton()) { intakeGamePiece(); }","title":"If, If-Else, and Else-If Statements"},{"location":"I%27m%20New%20Here/Java%20Overview/introtoarraylists/","text":"Intro to ArrayLists What are ArrayLists? ArrayList is a resizable array implementation in Java. Unlike regular arrays, ArrayLists can grow and shrink dynamically, making them more flexible for many use cases. Creating ArrayLists ArrayList syntax: import java.util.ArrayList; // Create empty ArrayList of Integers ArrayList<Integer> numbers = new ArrayList<>(); // Create ArrayList of Strings ArrayList<String> names = new ArrayList<>(); // Create with initial values ArrayList<Double> speeds = new ArrayList<>(); speeds.add(0.5); speeds.add(0.7); speeds.add(0.9); Note : ArrayLists use wrapper classes for primitives: - Integer instead of int - Double instead of double - Boolean instead of boolean Common ArrayList Operations Adding elements : ArrayList<String> teams = new ArrayList<>(); teams.add(\"Rancho Reapers\"); // Add to end teams.add(0, \"First Team\"); // Add at index Accessing elements : String first = teams.get(0); // Get element at index int size = teams.size(); // Get number of elements Removing elements : teams.remove(0); // Remove by index teams.remove(\"Rancho Reapers\"); // Remove by value teams.clear(); // Remove all elements Checking contents : boolean hasTeam = teams.contains(\"Rancho Reapers\"); boolean isEmpty = teams.isEmpty(); Iterating Through ArrayLists ArrayList<Integer> motorIDs = new ArrayList<>(); motorIDs.add(1); motorIDs.add(2); motorIDs.add(3); // For-each loop for (int id : motorIDs) { System.out.println(\"Motor ID: \" + id); } // Indexed loop for (int i = 0; i < motorIDs.size(); i++) { System.out.println(\"Motor \" + i + \": \" + motorIDs.get(i)); } ArrayList vs Array Use ArrayList when : - Size changes frequently - Need to insert/remove elements - Want built-in utility methods Use Array when : - Size is fixed and known - Need maximum performance - Working with primitive types directly","title":"Intro to ArrayLists"},{"location":"I%27m%20New%20Here/Java%20Overview/introtoarrays/","text":"Intro to Arrays What are Arrays? An array is a fixed-size container that holds multiple values of the same type. Arrays allow you to store and access collections of related data using a single variable. Declaring and Creating Arrays Array syntax: // Declare array variable int[] numbers; // Create array with size 5 numbers = new int[5]; // Declare and create in one line double[] speeds = new double[4]; // Initialize with values String[] names = {\"Alice\", \"Bob\", \"Charlie\"}; int[] motorIDs = {1, 2, 3, 4}; Accessing Array Elements Use index notation (zero-based indexing): int[] values = {10, 20, 30, 40, 50}; int first = values[0]; // 10 int third = values[2]; // 30 values[1] = 25; // Change second element // Array length int size = values.length; // 5 Important Array Concepts Key points about arrays: - Fixed size : Cannot change size after creation - Zero-indexed : First element is at index 0 - Type-safe : Can only hold declared type - Length property : array.length gives size - Bounds checking : Accessing invalid index throws ArrayIndexOutOfBoundsException Multi-dimensional Arrays Arrays can have multiple dimensions: // 2D array (matrix) int[][] grid = new int[3][4]; // 3 rows, 4 columns grid[0][0] = 1; // Initialize 2D array int[][] matrix = { {1, 2, 3}, {4, 5, 6} };","title":"Intro to Arrays"},{"location":"I%27m%20New%20Here/Java%20Overview/iteratingarrays/","text":"Iterating through Arrays Why Iterate Through Arrays? Iterating (looping) through arrays allows you to: - Process each element - Find specific values - Calculate totals or averages - Modify all elements - Search for conditions For Loop with Index Traditional indexed loop: int[] motorSpeeds = {0.5, 0.7, 0.3, 0.9}; for (int i = 0; i < motorSpeeds.length; i++) { System.out.println(\"Motor \" + i + \": \" + motorSpeeds[i]); motorSpeeds[i] *= 2; // Modify element } Enhanced For Loop (For-Each) Simplified syntax when you don't need the index: int[] scores = {95, 87, 92, 88, 90}; int total = 0; for (int score : scores) { total += score; } double average = total / (double) scores.length; Note : For-each loops are read-only - you cannot modify array elements through the loop variable. While Loop Alternative iteration approach: int[] values = {1, 2, 3, 4, 5}; int index = 0; while (index < values.length) { System.out.println(values[index]); index++; } Common Patterns Find maximum value: int[] numbers = {23, 67, 12, 89, 45}; int max = numbers[0]; for (int num : numbers) { if (num > max) { max = num; } } Count elements meeting condition: double[] temperatures = {72.5, 85.3, 68.9, 91.2}; int hotDays = 0; for (double temp : temperatures) { if (temp > 80) { hotDays++; } }","title":"Iterating through Arrays"},{"location":"I%27m%20New%20Here/Java%20Overview/parameters/","text":"Parameters What are Parameters? Parameters (also called arguments) are values passed into methods/functions to provide input data. They allow methods to be flexible and reusable with different inputs. Defining Method Parameters Parameters are defined in the method signature: public void setMotorSpeed(double speed) { // speed is a parameter motor.set(speed); } public double calculateDistance(double x1, double y1, double x2, double y2) { // Four parameters return Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)); } Calling Methods with Arguments When calling a method, provide values (arguments) for each parameter: setMotorSpeed(0.75); // One argument double dist = calculateDistance(0, 0, 3, 4); // Four arguments Arguments must match the parameter types and order. Parameter Types Parameters can be: - Primitives : int, double, boolean, etc. - Objects : String, custom classes, etc. - Arrays : collections of values Best Practices Use descriptive parameter names Keep the number of parameters reasonable (3-4 max when possible) Consider using objects to group related parameters Document what each parameter represents","title":"Parameters"},{"location":"I%27m%20New%20Here/Java%20Overview/setters/","text":"Setters What are Setters? Setters (mutator methods) are methods that modify the value of a private field. They provide controlled write access to an object's internal data. Why Use Setters? Setters enable: - Input validation before changing values - Triggering side effects when values change - Logging or debugging when fields are modified - Maintaining object invariants - Protecting internal state consistency Setter Syntax Standard setter pattern: public class Motor { private double speed; private int deviceID; // Setter with validation public void setSpeed(double newSpeed) { // Validate input if (newSpeed >= -1.0 && newSpeed <= 1.0) { speed = newSpeed; } else { speed = 0.0; // Default safe value } } // Simple setter public void setDeviceID(int id) { deviceID = id; } } Using Setters Call setters to modify private fields: Motor motor = new Motor(); motor.setSpeed(0.75); motor.setDeviceID(5); Best Practices Always validate input in setters Use descriptive parameter names Consider what side effects should occur Don't always need both getter and setter for every field","title":"Setters"},{"location":"I%27m%20New%20Here/Java%20Overview/switchexpressions/","text":"Switch Expressions (Condensed Switch Statements) What are Switch Expressions? Switch expressions (Java 14+) are a modern, concise alternative to traditional switch statements. They can return values directly and use arrow syntax for cleaner code. Arrow Syntax Modern switch expressions use arrows (->): int state = 2; String status = switch (state) { case 0 -> \"Initializing\"; case 1 -> \"Running\"; case 2 -> \"Stopping\"; default -> \"Unknown\"; }; Advantages Over Traditional Switch Switch expressions provide: - No break needed : Each case is automatically isolated - Return values : Entire switch evaluates to a value - Exhaustiveness checking : Compiler ensures all cases covered - More concise : Less boilerplate code - Safer : No fall-through bugs Multi-line Case Blocks Use curly braces with yield for complex cases: String result = switch (mode) { case 0 -> \"Simple case\"; case 1 -> { // Multiple statements doSetup(); yield \"Complex case\"; // Use yield to return value } default -> \"Default\"; }; Multiple Case Labels Handle multiple values in one case: String dayType = switch (day) { case \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\" -> \"Weekday\"; case \"Saturday\", \"Sunday\" -> \"Weekend\"; default -> \"Invalid day\"; }; Practical FRC Example double speed = switch (driveMode) { case SLOW -> 0.3; case MEDIUM -> 0.6; case FAST -> 1.0; default -> 0.5; };","title":"Switch Expressions (Condensed Switch Statements)"},{"location":"I%27m%20New%20Here/Java%20Overview/switchstatements/","text":"Switch Statements What are Switch Statements? Switch statements provide a clean way to select one of many code blocks to execute based on the value of a variable. They're especially useful when you have many specific values to check. Basic Switch Syntax int state = 2; switch (state) { case 0: // Code for state 0 initialize(); break; case 1: // Code for state 1 running(); break; case 2: // Code for state 2 stopping(); break; default: // Code if no case matches error(); break; } The Break Statement The break statement exits the switch: - Without break , execution \"falls through\" to the next case - Fall-through is occasionally useful but usually unintended - Always use break unless intentionally falling through Switch with Strings Java allows switching on Strings: String command = \"forward\"; switch (command) { case \"forward\": moveForward(); break; case \"backward\": moveBackward(); break; case \"stop\": stop(); break; default: System.out.println(\"Unknown command\"); } When to Use Switch Use switch when: - Checking a single variable against multiple specific values - You have 3 or more cases - Values are constants (not ranges) Use if-else when: - Checking complex conditions - Comparing ranges - Using relational operators (>, <, etc.)","title":"Switch Statements"},{"location":"I%27m%20New%20Here/Java%20Overview/variablesdatatypes/","text":"Variables & Data Types What are Variables? Variables are containers that store data values in your program. Each variable has: - A name (identifier) for reference - A data type that defines what kind of data it holds - A value stored in memory Common Data Types in Java Primitive data types: - int : Whole numbers (e.g., 42, -17, 0) - double : Decimal numbers (e.g., 3.14, -0.5, 2.0) - boolean : True or false values - char : Single characters (e.g., 'A', '7', '$') Reference types: - String : Text sequences (e.g., \"Hello\", \"Team 8533\") - Arrays : Collections of similar data - Objects : Custom data structures Declaring and Initializing Variables Variable declaration syntax: int motorSpeed; // Declaration motorSpeed = 100; // Assignment double armAngle = 45.0; // Declaration and initialization boolean isEnabled = true; // Declaration and initialization String teamName = \"Rancho Reapers\"; Variable Naming Conventions Follow Java naming conventions: - Use camelCase (e.g., motorSpeed, armAngle) - Start with lowercase letter - Use descriptive names - Constants use UPPER_SNAKE_CASE (e.g., MAX_SPEED)","title":"Variables & Data Types"},{"location":"I%27m%20New%20Here/Notes/notes/","text":"Notes Subheading","title":"Notes"},{"location":"I%27m%20New%20Here/Programs%20Overview/choreo/","text":"Choreo Overview What is Choreo? Choreo is a trajectory generation and path planning tool designed specifically for FRC robots. It allows you to create smooth, optimized autonomous paths visually and export them for use in your robot code. Key Features Choreo provides: - Visual path editor with field overlay - Real-time path optimization - Support for swerve drive kinematics - Trajectory constraint handling (velocity, acceleration) - Export to various formats for WPILib - Integration with PathPlanner - Real robot simulation Creating Autonomous Paths To use Choreo: - Define your robot's physical parameters - Draw paths on the field using waypoints - Set constraints for each path segment - Preview trajectory timing and velocities - Export trajectories for robot code - Test paths in simulation before competition","title":"Choreo"},{"location":"I%27m%20New%20Here/Programs%20Overview/elastic/","text":"Elastic Dashboard Overview What is Elastic? Elastic is a flexible, customizable dashboard application for FRC robots. It displays telemetry data from your robot and provides widgets for visualization, tuning, and control during testing and competitions. Key Features Elastic provides: - Customizable dashboard layouts - NetworkTables integration for real-time data - Various widget types (graphs, sliders, buttons, cameras) - Drag-and-drop interface builder - Support for camera streams - Autonomous routine selector - PID tuning interfaces - Field visualization for odometry Using Elastic To use Elastic: - Install Elastic on your driver station - Connect to robot's NetworkTables - Add widgets for the data you want to monitor - Arrange widgets in a useful layout - Save layouts for different purposes (tuning, competition, etc.) - Stream camera feeds from Limelight or other sources - Use for real-time robot diagnostics and tuning","title":"Elastic"},{"location":"I%27m%20New%20Here/Programs%20Overview/frcdriverstation/","text":"FRC Driver Station Overview What is the FRC Driver Station? The FRC Driver Station is the required software interface for controlling your robot. It runs on the driver station laptop and provides controls, telemetry display, and communication with the robot and field management system. Key Features The Driver Station provides: - Enable/disable robot control - Robot mode selection (TeleOperated, Autonomous, Test) - Joystick/controller input handling - Robot communication status monitoring - Battery voltage display - Robot code diagnostics - Log viewing and downloading - Practice timer for match simulation Essential Operations Common Driver Station tasks: - Connect to robot via Ethernet or WiFi - Enable robot for testing or matches - Switch between autonomous and teleop modes - Monitor battery voltage and communication status - View error messages and warnings - Use USB tab to configure controllers - Set team number and station selection","title":"FRC Driver Station"},{"location":"I%27m%20New%20Here/Programs%20Overview/limelighthardwaremanager/","text":"Limelight Hardware Manager Overview What is Limelight Hardware Manager? Limelight Hardware Manager is a desktop application for configuring, updating, and managing Limelight smart cameras. It provides an easy interface for firmware updates and initial camera setup. Key Functions The Hardware Manager allows you to: - Discover Limelights on your network - Update Limelight firmware - Flash Limelight images to new SD cards - Configure network settings - Backup and restore camera configurations - Manage multiple Limelights Using the Hardware Manager Common tasks: - Install the latest version from the Limelight downloads page - Connect to the same network as your Limelight - Select your Limelight from the device list - Check for and install firmware updates - Flash imaging data to Limelight SD card - Export/import camera configurations","title":"Limelight Hardware Manager"},{"location":"I%27m%20New%20Here/Reading%20Documentation/howtoreaddocs/","text":"How to Read Documentation Effectively Start with the Right Document Choose documentation based on your goal: - Learning a concept : Start with tutorials and guides - Finding a specific method : Use API reference - Troubleshooting : Check troubleshooting guides and forums - Examples : Look for sample code sections Active Reading Strategy Don't just passively read - engage with the material: 1. Skim First : - Read headings and subheadings - Look at code examples - Identify relevant sections - Get the big picture 2. Read Carefully : - Focus on relevant sections - Try to understand the concepts - Note unfamiliar terms - Check diagrams and tables 3. Try Examples : - Copy and run example code - Modify examples to test understanding - Break examples to see error messages - Compare results to documentation 4. Take Notes : - Write down key points - Document useful methods - Note common patterns - Create your own examples Understanding Technical Writing Technical documentation has specific conventions: Method Signatures : public double setSpeed(double speed) public : access level double : return type setSpeed : method name (double speed) : parameter type and name Parameter Descriptions : - Often in format: parameter - description - May include valid ranges or units - Example: speed - Motor speed from -1.0 to 1.0 Return Values : - Describes what the method returns - Includes type and meaning - Example: Returns: Current velocity in meters per second Common Documentation Sections Overview : High-level explanation of what something does Prerequisites : What you need to know or have first Installation : How to set up or import Quick Start : Minimal example to get started API Reference : Complete list of classes and methods Examples : Working code samples Troubleshooting : Common problems and solutions FAQ : Frequently asked questions Best Practices Search effectively : Use Ctrl+F to find specific terms Follow links : Documentation often references related topics Check versions : Make sure docs match your software version Use multiple sources : Cross-reference different documentation Test as you read : Try things in your own code Read error messages : They often contain helpful information Don't skip basics : Understanding fundamentals prevents issues later When Documentation Isn't Clear If documentation is confusing: 1. Look for video tutorials on the topic 2. Search for blog posts or team technical binders 3. Ask on Chief Delphi or FRC Discord with specific questions 4. Look at example robot code from successful teams 5. Experiment with simple test code 6. Ask experienced team members","title":"How to Read Documentation"},{"location":"I%27m%20New%20Here/Reading%20Documentation/links/","text":"Links to Important Documentation Official FRC Documentation WPILib Documentation : - URL: https://docs.wpilib.org/ - Contains: Complete FRC programming guide - Topics: Command-based programming, hardware, simulation, vision FRC Game Manual : - URL: https://www.firstinspires.org/resource-library/frc/competition-manual-qa-system - Contains: Game rules, robot regulations, safety requirements - Updated annually for each season Hardware Documentation REV Robotics : - URL: https://docs.revrobotics.com/ - Covers: SPARK MAX, PDH, NEO motors, Through Bore Encoder CTRE Phoenix Documentation : - URL: https://v6.docs.ctr-electronics.com/ - Covers: CANCoders, TalonFX, Pigeon IMU, Phoenix 6 Limelight Documentation : - URL: https://docs.limelightvision.io/ - Covers: Camera setup, pipelines, AprilTags, neural networks Studica NavX : - URL: https://pdocs.kauailabs.com/navx-mxp/ - Covers: IMU setup, calibration, programming Software Tools Documentation Choreo Path Planner : - URL: https://sleipnirgroup.github.io/Choreo/ - Covers: Creating trajectories, exporting for WPILib PathPlanner : - URL: https://pathplanner.dev/home.html - Covers: Auto path creation, event markers, on-the-fly generation Git and GitHub : - Git Handbook: https://guides.github.com/introduction/git-handbook/ - GitHub Docs: https://docs.github.com/ Java Language : - Oracle Java Tutorials: https://docs.oracle.com/javase/tutorial/ - Java SE Documentation: https://docs.oracle.com/en/java/javase/ Team Resources Chief Delphi : - URL: https://www.chiefdelphi.com/ - FRC community forum for discussions and questions FRC Discord : - URL: https://discord.gg/frc - Real-time help from FRC community YouTube Channels : - FRC 0 to Autonomous - Team 254 (Cheesy Poofs) - Various team technical binder presentations Keeping Links Updated Documentation URLs can change. If a link is broken: - Search for the component name + \"documentation\" - Check the manufacturer's main website - Ask on Chief Delphi or FRC Discord - Update this page with the new URL","title":"Links to Important Documentation"},{"location":"I%27m%20New%20Here/Reading%20Documentation/whyreaddocs/","text":"Why Read Documentation? The Importance of Documentation Reading documentation is one of the most important skills in programming and robotics. Good documentation habits will: - Save you hours of troubleshooting - Help you understand how components really work - Enable you to use advanced features - Prevent you from reinventing solutions - Build your technical reading skills Common Misconceptions Many beginners avoid documentation because they think: - \"It's too technical\" - Documentation is written for learners - \"I can figure it out myself\" - You'll waste time on solved problems - \"I'll just ask someone\" - They'll tell you to read the docs - \"It's boring\" - It's actually faster than trial and error When to Read Documentation You should consult documentation when: - Learning a new library or framework - Encountering an error message - Wanting to use a specific feature - Optimizing existing code - Debugging unexpected behavior - Planning a new feature implementation Types of Documentation Different documentation serves different purposes: API Reference : - Lists all classes, methods, and parameters - Shows method signatures and return types - Essential for knowing what's available Tutorials and Guides : - Step-by-step instructions - Best for learning concepts - Show complete examples Examples and Sample Code : - Working code you can adapt - Demonstrate best practices - Great starting points Troubleshooting Guides : - Common problems and solutions - Error message explanations - Diagnostic procedures Benefits for FRC Teams Teams that read documentation: - Spend less time stuck on problems - Write better, more maintainable code - Use hardware features correctly - Avoid common mistakes - Build expertise faster - Perform better in competitions","title":"Why Read Documentation?"},{"location":"I%27m%20New%20Here/VS%20Code%20Overview/gitinvscode/","text":"Git in VS Code Source Control Panel VS Code has built-in Git integration accessible through the Source Control panel (Ctrl+Shift+G). This panel shows: - Changed files - Staged changes - Commit history - Branch information - Sync status with remote Common Git Operations in VS Code VS Code makes Git operations visual: - Viewing Changes : Click on a file to see a diff view - Staging : Click the \"+\" icon next to a file - Unstaging : Click the \"-\" icon next to a staged file - Committing : Type message in text box and click checkmark - Pulling/Pushing : Use sync button or three-dot menu - Creating Branches : Click branch name in status bar - Switching Branches : Select from branch list Git Timeline and History VS Code provides: - Timeline view showing file commit history - GitLens extension for enhanced Git features (optional) - Inline blame annotations - Commit graph visualization - Compare changes between commits Resolving Merge Conflicts When conflicts occur, VS Code: - Highlights conflicted files - Provides \"Accept Current Change\" / \"Accept Incoming Change\" buttons - Shows diff view with both versions - Allows manual editing to combine changes - Marks files as resolved when saved","title":"Git in VS Code"},{"location":"I%27m%20New%20Here/VS%20Code%20Overview/vendordeps/","text":"Vendor Dependencies What are Vendor Dependencies? Vendor dependencies (vendordeps) are libraries provided by hardware manufacturers and third parties that add support for their devices in WPILib. Examples include: - REV Robotics (SPARK MAX, PDH) - CTRE Phoenix (CANCoders, Talons, Pigeons) - Kauai Labs (NavX) - PhotonVision - PathPlanner Managing Vendor Dependencies To add a vendor dependency: 1. Press Ctrl+Shift+P (Cmd+Shift+P on Mac) 2. Type \"WPILib: Manage Vendor Libraries\" 3. Select \"Install new library (online)\" 4. Enter the JSON URL from the vendor's website 5. The library will be downloaded and configured Common vendordep URLs are typically found on: - Vendor documentation websites - GitHub release pages - FRC documentation The vendordeps Folder Vendor dependencies are stored as JSON files in the vendordeps folder. Each JSON file: - Specifies library version - Lists required Java dependencies - Defines native libraries for different platforms - Configures Maven repository URLs Updating Vendor Dependencies To update vendordeps: 1. Open WPILib Command Palette 2. Select \"WPILib: Manage Vendor Libraries\" 3. Choose \"Check for updates (online)\" 4. Select which libraries to update 5. Rebuild the project after updating","title":"Vendor Dependencies"},{"location":"I%27m%20New%20Here/VS%20Code%20Overview/vscodebasics/","text":"VS Code Basics and the WPILib Extension What is VS Code? Visual Studio Code (VS Code) is a free, powerful code editor that serves as the official IDE for FRC Java development. The WPILib extension adds FRC-specific features for robot programming. Essential VS Code Features VS Code provides: - Syntax highlighting and code completion - Built-in Git integration - Integrated terminal - Extensions for additional functionality - Debugging tools - File explorer and search - Split editor views WPILib Extension Features The WPILib extension adds: - FRC project creation and management - Robot code deployment to SystemCore/RoboRIO - Command palette for FRC-specific tasks - Library and vendor dependency management - Simulation support - Build and test commands - Integration with FRC tools Getting Started To start using VS Code for FRC: - Install WPILib (includes VS Code configured for FRC) - Open VS Code through the WPILib shortcut - Access WPILib commands via Ctrl+Shift+P (Cmd+Shift+P on Mac) - Type \"WPILib\" to see all available commands","title":"VS Code Basics and the WPILib Extension"}]}